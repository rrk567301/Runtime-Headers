@class NSString, TSDStrokePattern, TSUColor;

@interface TSDStroke : NSObject <TSSPropertyCommandSerializing, TSDPathPainter, TSDMixing, NSCopying, NSMutableCopying>

@property (class, readonly, nonatomic) TSUColor *colorOnSuppressedBackgrounds;

@property (readonly) unsigned long long hash;
@property (readonly) Class superclass;
@property (readonly, copy) NSString *description;
@property (readonly, copy) NSString *debugDescription;
@property (copy, nonatomic) TSUColor *i_color;
@property (nonatomic) double i_width;
@property (nonatomic) double i_actualWidth;
@property (nonatomic, setter=i_setCap:) int i_cap;
@property (nonatomic) int i_join;
@property (nonatomic) double i_miterLimit;
@property (copy, nonatomic, setter=i_setPattern:) TSDStrokePattern *i_pattern;
@property (readonly, copy, nonatomic) TSUColor *color;
@property (readonly, nonatomic) double width;
@property (readonly, nonatomic) double renderedWidth;
@property (readonly, nonatomic) double actualWidth;
@property (readonly, nonatomic) int cap;
@property (readonly, nonatomic) int join;
@property (readonly, nonatomic) double miterLimit;
@property (readonly, copy, nonatomic) TSDStrokePattern *pattern;
@property (readonly, nonatomic) char isNullStroke;
@property (readonly, nonatomic) char isDash;
@property (readonly, nonatomic) char isRoundDash;
@property (readonly, nonatomic) char shouldRender;
@property (readonly, nonatomic) char supportsPattern;
@property (readonly, nonatomic) char supportsWidth;
@property (readonly, nonatomic) char supportsColor;
@property (readonly, nonatomic) char supportsLineOptions;
@property (readonly, nonatomic) double suggestedMinimumLineWidth;
@property (readonly, nonatomic) char isFrame;
@property (readonly, nonatomic) char isNearlyWhite;
@property (readonly, nonatomic) double dashSpacing;
@property (readonly, nonatomic) char drawsOutsideStrokeBounds;
@property (readonly, nonatomic) char needsToExtendJoinsForBoundsCalculation;
@property (readonly, nonatomic) struct _TSDStrokeOutsets { double x0; double x1; double x2; double x3; } outsets;
@property (readonly, nonatomic) char drawsInOneStep;
@property (readonly, nonatomic) char shouldAntialiasDefeat;
@property (readonly, nonatomic) char usesOpenGL;
@property (readonly) unsigned long long hash;
@property (readonly) Class superclass;
@property (readonly, copy) NSString *description;
@property (readonly, copy) NSString *debugDescription;

+ (id)stroke;
+ (Class)mutableClass;
+ (char)canMixWithNilObjects;
+ (id)editedStrokeFromModelStroke:(id)a0 selectedStroke:(id)a1;
+ (id)emptyStroke;
+ (id)i_newEmptyStroke;
+ (id)i_newStroke;
+ (long long)indexOfStroke:(id)a0 strokeArray:(id)a1;
+ (id)strokeWithColor:(id)a0 width:(double)a1;
+ (id)strokeWithColor:(id)a0 width:(double)a1 cap:(int)a2 join:(int)a3 pattern:(id)a4;
+ (id)instanceWithArchive:(const void *)a0 unarchiver:(id)a1;

- (id)copyWithZone:(struct _NSZone { } *)a0;
- (id)init;
- (char)isEqual:(id)a0;
- (id)mutableCopyWithZone:(struct _NSZone { } *)a0;
- (void).cxx_destruct;
- (void)paintPath:(struct CGPath { } *)a0 inContext:(struct CGContext { } *)a1;
- (void)paintRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 inContext:(struct CGContext { } *)a1;
- (void)applyToContext:(struct CGContext { } *)a0;
- (void)paintLineEnd:(id)a0 atPoint:(struct CGPoint { double x0; double x1; })a1 atAngle:(double)a2 withScale:(double)a3 inContext:(struct CGContext { } *)a4;
- (void)paintLineEnd:(id)a0 atPoint:(struct CGPoint { double x0; double x1; })a1 atAngle:(double)a2 withScale:(double)a3 inContext:(struct CGContext { } *)a4 useFastDrawing:(char)a5;
- (id)strokeLineEnd:(id)a0;
- (void)applyInteriorWrapPropertiesToContext:(struct CGContext { } *)a0 insideStroke:(char)a1;
- (void)applyToContext:(struct CGContext { } *)a0 insideStroke:(char)a1;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })boundsForLineEnd:(id)a0 atPoint:(struct CGPoint { double x0; double x1; })a1 atAngle:(double)a2 withScale:(double)a3 transform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a4;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })boundsForPath:(id)a0;
- (char)canDrawWithOtherStroke:(id)a0;
- (id)colorForCGContext:(struct CGContext { } *)a0;
- (void)drawSwatchInRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 inContext:(struct CGContext { } *)a1;
- (double)horizontalMarginForSwatch;
- (void)i_setPatternPropertiesFromStroke:(id)a0;
- (void)i_setPropertiesFromStroke:(id)a0;
- (id)initWithArchive:(const void *)a0 unarchiver:(id)a1;
- (id)initWithColor:(id)a0 width:(double)a1 cap:(int)a2 join:(int)a3 pattern:(id)a4;
- (id)initWithColor:(id)a0 width:(double)a1 cap:(int)a2 join:(int)a3 pattern:(id)a4 miterLimit:(double)a5;
- (double)lineEndInsetAdjustment;
- (id)mixedObjectWithFraction:(double)a0 ofObject:(id)a1;
- (void)p_strokePathChunk:(struct CGPath { } *)a0 inContext:(struct CGContext { } *)a1 wantsInteriorStroke:(char)a2;
- (void)paintPath:(struct CGPath { } *)a0 wantsInteriorStroke:(char)a1 inContext:(struct CGContext { } *)a2;
- (void)paintPath:(struct CGPath { } *)a0 wantsInteriorStroke:(char)a1 inContext:(struct CGContext { } *)a2 useFastDrawing:(char)a3 parameterized:(char)a4 shouldReverseDrawOrder:(char)a5;
- (void)paintRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 wantsInteriorStroke:(char)a1 inContext:(struct CGContext { } *)a2;
- (id)pathForLineEnd:(id)a0 wrapPath:(char)a1 atPoint:(struct CGPoint { double x0; double x1; })a2 atAngle:(double)a3 withScale:(double)a4;
- (struct CGPath { } *)pathToStrokeFromCGPath:(struct CGPath { } *)a0;
- (id)strokeByTransformingByTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a0;
- (long long)mixingTypeWithObject:(id)a0 context:(id)a1;
- (void)saveToArchive:(void *)a0 archiver:(id)a1;
- (id)initFromPropertyCommandMessage:(const struct Message { void /* function */ **x0; struct InternalMetadata { void *x0; } x1; } *)a0 unarchiver:(id)a1;
- (char)p_isRoundSolidLine;
- (id)pathToStrokeFromTSUBezierPath:(id)a0;
- (char)requiresOutlineOnBackgroundWithAppearance:(unsigned long long)a0;
- (void)saveToPropertyCommandMessage:(struct Message { void /* function */ **x0; struct InternalMetadata { void *x0; } x1; } *)a0 archiver:(id)a1;

@end
