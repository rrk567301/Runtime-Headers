@class NSMutableArray, CMCaptureFrameSenderService, BWStats, BWLimitedGMErrorLogger, CAContext, NSObject, BWFigVideoCaptureDevice;
@protocol OS_os_transaction, BWImageQueueSinkNodePreviewTapDelegate, OS_dispatch_queue;

@interface BWImageQueueSinkNode : BWSinkNode {
    unsigned int _imageQueueCapacity;
    unsigned int _imageQueueWidth;
    unsigned int _imageQueueHeight;
    unsigned int _imageQueueRequiredFreeSlots;
    struct _CAImageQueue { } *_imageQueue;
    unsigned int _imageQueueSlot;
    unsigned long long _imageQueueCurrentFreeSlots;
    CMCaptureFrameSenderService *_frameSender;
    struct { unsigned int val[8]; } _frameSenderClientAuditToken;
    int _syncStrategy;
    int _liveSyncStrategy;
    char _resetPreviewSynchronizerOnNextFrame;
    struct OpaqueBWPreviewSynchronizer { } *_previewSynchronizer;
    double _lastDisplaySamplingTime;
    double _lastDisplayVSyncInterval;
    double _lastHarmonicFractionalVSyncInterval;
    double _lastFramePTS;
    double _lastDisplayTime;
    double _lateFrameIntervalStartPTS;
    double _previousFrameDuration;
    unsigned long long _framesSinceLastHarmonicCompensation;
    char _CAVSyncIntervalWorkaroundEnabled;
    char _highLatencyJitterHandlingEnabled;
    char _fasterLatencyRecoveryEnabled;
    char _driftCompensationTimestampFilteringEnabled;
    unsigned long long _numFramesReceived;
    unsigned long long _numFramesReceivedBeforeFirstDisplayTimeout;
    char _receivingBlackenedFrames;
    NSObject<OS_os_transaction> *_holdingBuffersForClientAssertion;
    NSMutableArray *_sharedSurfaces;
    unsigned long long *_sharedBufferIDs;
    unsigned long long _sharedSurfaceCount;
    char _renderingTCCPlaceholderFrames;
    struct OpaqueFigSimpleMutex { } *_surfaceRegistrationMutex;
    NSMutableArray *_bufferIDsInQueue;
    struct _EnqueuedBufferContext **_enqueuedBufferContexts;
    unsigned long long _enqueuedBufferContextCount;
    NSMutableArray *_previewPTSHistory;
    struct OpaqueFigSimpleMutex { } *_previewPTSHistoryMutex;
    NSObject<OS_dispatch_queue> *_previewPTSHistoryQueue;
    struct { long long value; int timescale; unsigned int flags; long long epoch; } _firstFramePTS;
    long long _firstDisplayedFrameHostTime;
    struct { long long value; int timescale; unsigned int flags; long long epoch; } _firstDisplayedFramePTS;
    char _didCallFirstFrameAtHostTimeCallback;
    char _didCallFirstFrameCallback;
    struct { long long value; int timescale; unsigned int flags; long long epoch; } _firstOverCaptureDisplayedFramePTS;
    long long _firstOverCaptureDisplayedFrameHostTime;
    char _didLogFirstOverCaptureFrame;
    char _triggerDisplayTimeout;
    char _fenceSupportEnabled;
    char _fencePortGenerationIDWillChange;
    int _framesSinceLastFenceIDWillChange;
    int _framesSinceLastFence;
    long long _lastFencedGenerationID;
    int _savedSyncStrategy;
    CAContext *_imageQueueContext;
    int _maxLossyCompressionLevel;
    struct FigCaptureVideoTransform { char mirrored; int rotationDegrees; struct { int width; int height; } dimensions; } _transform;
    BWStats *_frameDisplayLatencyStats;
    int _clientPID;
    struct { unsigned int val[8]; } _clientAuditToken;
    struct os_unfair_lock_s { unsigned int _os_unfair_lock_opaque; } _clientPIDLock;
    char _videoHDRImageStatisticsEnabled;
    char _liveVideoHDRImageStatisticsEnabled;
    BWLimitedGMErrorLogger *_limitedGMErrorLogger;
}

@property (readonly, nonatomic) struct _CAImageQueue { } *imageQueue;
@property (readonly, nonatomic) unsigned int imageQueueSlot;
@property (nonatomic) id<BWImageQueueSinkNodePreviewTapDelegate> previewTapDelegate;
@property (retain, nonatomic) BWFigVideoCaptureDevice *captureDevice;
@property (nonatomic) char cleanupImageQueueAtEndOfData;

+ (void)initialize;

- (void)dealloc;
- (struct FigCaptureVideoTransform { char x0; int x1; struct { int x0; int x1; } x2; })transform;
- (void)setTransform:(struct FigCaptureVideoTransform { char x0; int x1; struct { int x0; int x1; } x2; })a0;
- (void)fencePortGenerationIDWillChange;
- (void)registerSurfacesFromSourcePool:(id)a0;
- (void)configurationWithID:(long long)a0 updatedFormat:(id)a1 didBecomeLiveForInput:(id)a2;
- (void)didReachEndOfDataForInput:(id)a0;
- (char)fenceSupportEnabled;
- (void)handleDroppedSample:(id)a0 forInput:(id)a1;
- (char)hasNonLiveConfigurationChanges;
- (id)initWithHFRSupport:(char)a0 ispJitterCompensationEnabled:(char)a1 clientAuditToken:(struct { unsigned int x0[8]; })a2 sinkID:(id)a3;
- (void)inputConnectionWillBeEnabled;
- (void)makeCurrentConfigurationLive;
- (int)maxLossyCompressionLevel;
- (id)nodeSubType;
- (void)prepareForCurrentConfigurationToBecomeLive;
- (struct { long long x0; int x1; unsigned int x2; long long x3; })previewPTSAtHostTime:(unsigned long long)a0;
- (struct { long long x0; int x1; unsigned int x2; long long x3; })previewPTSDisplayedAtHostTime:(unsigned long long)a0 allowingExtrapolation:(char)a1;
- (void)renderSampleBuffer:(struct opaqueCMSampleBuffer { } *)a0 forInput:(id)a1;
- (void)setFenceSupportEnabled:(char)a0;
- (void)setMaxLossyCompressionLevel:(int)a0;
- (void)setSyncStrategy:(int)a0;
- (void)setVideoHDRImageStatisticsEnabled:(char)a0;
- (int)syncStrategy;
- (void)updateClientAuditToken:(struct { unsigned int x0[8]; })a0;
- (char)videoHDRImageStatisticsEnabled;

@end
