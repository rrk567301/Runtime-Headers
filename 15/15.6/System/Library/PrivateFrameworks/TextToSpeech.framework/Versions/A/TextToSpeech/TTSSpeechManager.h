@class TTSSpeechAction, NSString, NSArray, AXDispatchTimer, AVAudioSession, NSLock, NSObject, NSMutableArray, TTSSpeechSynthesizer, NSNumber, TTSSpeechThread;
@protocol OS_dispatch_queue;

@interface TTSSpeechManager : NSObject <TTSSpeechSynthesizerDelegate> {
    NSMutableArray *_speechQueue;
    TTSSpeechSynthesizer *_synthesizer;
    TTSSpeechThread *_runThread;
    NSObject<OS_dispatch_queue> *_propertyQueue;
    char _isSpeaking;
    char _audioSessionObserversEnabled;
    char _speechThreadFinished;
    NSLock *_speechThreadQueueLock;
}

@property (retain, nonatomic) NSNumber *originalSpeechRateForJobOverride;
@property (nonatomic) char isPaused;
@property (retain, nonatomic) AXDispatchTimer *audioDeactivatorTimer;
@property (retain, nonatomic) NSObject<OS_dispatch_queue> *audioOperationQueue;
@property (nonatomic) char wasSpeakingBeforeAudioInterruption;
@property (nonatomic) char didRequestStartSpeakingDuringAudioInterruption;
@property (nonatomic) char didRequestPauseSpeakingDuringAudioInterruption;
@property (nonatomic) char didRequestResumeSpeakingDuringAudioInterruption;
@property (nonatomic) double audioInterruptionStartedTime;
@property (retain, nonatomic) AVAudioSession *audioSession;
@property (nonatomic) char isInAudioInterruption;
@property (retain, nonatomic) TTSSpeechAction *requestedActionDuringAudioInterruption;
@property (nonatomic) char shouldHandleAudioInterruptions;
@property (nonatomic) char speechEnabled;
@property (retain, nonatomic) NSString *speechSource;
@property (readonly, nonatomic) char showControlCenterControls;
@property (readonly, nonatomic) char isSpeaking;
@property (nonatomic) unsigned int audioQueueFlags;
@property (nonatomic) char usesAuxiliarySession;
@property (nonatomic) unsigned int audioDeviceId;
@property (nonatomic) unsigned long long setActiveOptions;
@property (retain, nonatomic) NSString *audioSessionCategory;
@property (nonatomic) unsigned long long audioSessionCategoryOptions;
@property (retain, nonatomic) NSArray *outputChannels;
@property (nonatomic) double audioSessionInactiveTimeout;
@property (copy, nonatomic) id /* block */ requestWillStart;
@property (readonly) unsigned long long hash;
@property (readonly) Class superclass;
@property (readonly, copy) NSString *description;
@property (readonly, copy) NSString *debugDescription;

+ (id)availableVoices;
+ (id)currentLanguageCode;
+ (id)languageCodeForVoiceIdentifier:(id)a0;
+ (char)_isCharacterNativelySpeakable:(unsigned short)a0 languageCode:(id)a1;
+ (id)_resetAvailableVoices;
+ (id)_resetAvailableVoices:(char)a0;
+ (id)audioFileSettingsForVoice:(id)a0;
+ (id)avSpeechVoicesForTTSAXResources:(id)a0;
+ (id)availableLanguageCodes;
+ (id)availableSuperCompactVoices;
+ (id)availableVoices:(char)a0;
+ (struct URegularExpression { } *)createRegularExpressionFromString:(id)a0;
+ (char)currentProcessAllowedToSaveVoiceInfo;
+ (id)literalStringMarkup:(id)a0 string:(id)a1 speakCap:(char)a2;
+ (id)matchedRangesForString:(id)a0 withRegularExpression:(struct URegularExpression { } *)a1;
+ (id)pauseMarkupString:(id)a0;
+ (id)remapLanguageCode:(id)a0;
+ (id)spellOutLetterCaseMarkupString:(id)a0 string:(id)a1;
+ (id)spellOutMarkupString:(id)a0 string:(id)a1;
+ (void)test_actionStartTap:(id /* block */)a0;
+ (void)test_setAvailableVoices:(id)a0;
+ (void)test_setUnitTestMode:(char)a0;

- (void)dealloc;
- (id)init;
- (void).cxx_destruct;
- (void)observeValueForKeyPath:(id)a0 ofObject:(id)a1 change:(id)a2 context:(void *)a3;
- (void)_continueSpeaking;
- (void)continueSpeaking;
- (char)isSpeaking;
- (void)stopSpeaking;
- (void)stopSpeaking:(long long)a0;
- (void)tearDown;
- (void)_tearDown;
- (void)speechSynthesizer:(id)a0 didContinueSpeakingRequest:(id)a1;
- (void)speechSynthesizer:(id)a0 didEncounterMarker:(id)a1 forRequest:(id)a2;
- (void)speechSynthesizer:(id)a0 didFinishSpeakingRequest:(id)a1 successfully:(char)a2 withError:(id)a3;
- (void)speechSynthesizer:(id)a0 didPauseSpeakingRequest:(id)a1;
- (void)speechSynthesizer:(id)a0 didStartSpeakingRequest:(id)a1;
- (void)_initialize;
- (void)_pauseSpeaking:(id)a0;
- (id)voiceIdentifierUsedForLanguage:(id)a0;
- (id)_phonemeSubstitutionsForAction:(id)a0;
- (void)__speechJobFinished:(id)a0;
- (void)_clearSpeechQueue;
- (void)_didBeginInterruption;
- (void)_didEndInterruption;
- (void)_dispatchSpeechAction:(id)a0;
- (char)_enqueueSelectorOnSpeechThread:(SEL)a0 object:(id)a1 waitUntilDone:(char)a2;
- (void)_handleAudioInterruption:(id)a0;
- (void)_handleMediaServicesWereLost:(id)a0;
- (void)_handleMediaServicesWereReset:(id)a0;
- (void)_isSpeaking:(id)a0;
- (void)_processAudioBufferCallback:(id)a0;
- (void)_processDidContinueCallback:(id)a0;
- (void)_processDidEncounterMarker:(id)a0;
- (void)_processDidPauseCallback:(id)a0;
- (void)_processDidStartCallback:(id)a0;
- (void)_processWillSpeechRange:(id)a0;
- (void)_resetInterruptionTracking;
- (void)_setVoiceForAction:(id)a0 snippet:(id)a1;
- (void)_speechJobFinished:(char)a0 action:(id)a1;
- (void)_startNextSpeechJob;
- (void)_stopSpeaking:(id)a0;
- (void)_updateAudioSessionProperties;
- (void)_updateAuxiliarySession;
- (void)_updateUserSubstitutions;
- (void)clearSpeechQueue;
- (void)dispatchSpeechAction:(id)a0;
- (id)externalVoiceIdentifierUsedForLanguage:(id)a0;
- (void)handleAudioInterruption:(id)a0;
- (void)handleAudioSessionObservers:(char)a0;
- (void)handleMediaServicesWereLost:(id)a0;
- (void)handleMediaServicesWereReset:(id)a0;
- (void)pauseSpeaking:(long long)a0;

@end
