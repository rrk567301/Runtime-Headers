@class NSError, NSString, AVMediaDataRequester, NSArray, AVSampleBufferDisplayLayer, AVApplicationStateMonitor, AVSampleBufferRenderSynchronizer, AVContentKeySession, NSObject, NSMutableArray;
@protocol OS_dispatch_queue;

@interface AVSampleBufferVideoRenderer : NSObject <AVMediaDataRequesterConsumer, AVFigVideoQueueFactory, AVQueuedSampleBufferRenderingInternal, AVQueuedSampleBufferRendering> {
    struct OpaqueFigVideoQueue { } *_videoQueue;
    char _outputObscured;
    long long _status;
    NSError *_error;
    AVSampleBufferDisplayLayer *_weakDisplayLayer;
    char _containsDisplayLayer;
    struct __CFArray { } *_figVideoTargets;
    struct CGRect { struct CGPoint { double x; double y; } origin; struct CGSize { double width; double height; } size; } _previousSourceRect;
    AVApplicationStateMonitor *_applicationStateMonitor;
    char _preventsDisplaySleepDuringVideoPlayback;
    char _preventsAutomaticBackgroundingDuringVideoPlayback;
    char _requiresFlushToResumeDecoding;
    char _disallowsVideoLayerDisplayCompositing;
    char _shouldWaitForVideoTarget;
    char _hasEverEnqueued;
    char _isRequestingMediaData;
    AVMediaDataRequester *_mediaDataRequester;
    char _readyForDisplay;
    char _aboveHighWaterLevel;
    char _createVideoQueueFailed;
    NSObject<OS_dispatch_queue> *_serialQueue;
    NSObject<OS_dispatch_queue> *_videoQueueQueue;
    NSObject<OS_dispatch_queue> *_layerQueue;
    NSObject<OS_dispatch_queue> *_videoPerformanceMetricsQueue;
    AVSampleBufferRenderSynchronizer *_weakReferenceToSynchronizer;
    char _addedToSynchronizer;
    char _controlTimebaseSetByUserIsInUse;
    struct OpaqueCMTimebase { } *_controlTimebaseSetByUser;
    struct OpaqueCMTimebase { } *_readOnlyVideoQueueTimebase;
    struct OpaqueCMTimebase { } *_readOnlyRenderingTimebase;
    NSMutableArray *_videoOutputs;
    NSObject<OS_dispatch_queue> *_flushCallbackListQueue;
    NSObject<OS_dispatch_queue> *_flushCallbackQueue;
    NSMutableArray *_flushCallbacks;
    NSObject<OS_dispatch_queue> *_queueForProtectingPrerollCompleteCallback;
    id /* block */ _pendingPrerollCompleteCallback;
    int _pendingPrerollRequestID;
    NSObject<OS_dispatch_queue> *_queueForCallingPrerollCompleteCallback;
    int _upcomingPTSExpectation;
    struct { long long value; int timescale; unsigned int flags; long long epoch; } _minimumUpcomingPTS;
    AVContentKeySession *_weakContentKeySession;
    struct opaqueCMFormatDescription { } *_lastFormatDescription;
    struct OpaqueFigCPECryptor { } *_lastCryptor;
}

@property (readonly) char outputObscuredDueToInsufficientExternalProtection;
@property (nonatomic) char preventsCapture;
@property (nonatomic) char preventsDisplaySleepDuringVideoPlayback;
@property (nonatomic) char preventsAutomaticBackgroundingDuringVideoPlayback;
@property (getter=_disallowsVideoLayerDisplayCompositing, setter=_setDisallowsVideoLayerDisplayCompositing:) char disallowsVideoLayerDisplayCompositing;
@property (readonly, nonatomic) NSArray *outputs;
@property (copy, nonatomic, getter=_STSLabel) NSString *STSLabel;
@property (readonly) long long status;
@property (readonly) NSError *error;
@property (readonly) char requiresFlushToResumeDecoding;
@property (readonly) unsigned long long hash;
@property (readonly) Class superclass;
@property (readonly, copy) NSString *description;
@property (readonly, copy) NSString *debugDescription;
@property (readonly, retain) struct OpaqueCMTimebase { } *timebase;
@property (readonly, getter=isReadyForMoreMediaData) char readyForMoreMediaData;
@property (readonly, nonatomic) char hasSufficientMediaDataForReliablePlaybackStart;

+ (void)initialize;
+ (char)automaticallyNotifiesObserversForKey:(id)a0;

- (void)dealloc;
- (id)init;
- (void).cxx_destruct;
- (void)flush;
- (void)removeOutput:(id)a0;
- (void)setToneMapToStandardDynamicRange:(char)a0;
- (void)addOutput:(id)a0;
- (struct OpaqueFigVideoQueue { } *)_copyVideoQueue;
- (char)_setSynchronizerTimebase:(struct OpaqueCMTimebase { } *)a0 error:(id *)a1;
- (void)addVideoTarget:(struct OpaqueFigVideoTarget { } *)a0;
- (void)_updateVideoTargetsOnVideoQueue;
- (struct OpaqueCMTimebase { } *)controlTimebase;
- (void)_addFigVideoQueueListeners;
- (void)_callOldPrerollCompletionHandlerWithSuccess:(char)a0 andSetNewPrerollCompletionHandler:(id /* block */)a1 forRequestID:(int)a2;
- (void)_completedDecodeForPrerollForRequestID:(int)a0;
- (struct { struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; } x0; struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; } x1; })_computeSampleBufferEnqueueingInfoForSampleBuffer:(struct opaqueCMSampleBuffer { } *)a0;
- (int)_createVideoQueue:(struct OpaqueFigVideoQueue **)a0 errorStep:(id *)a1;
- (char)_createVideoQueueFailed;
- (int)_enqueueSingleSampleBuffer:(struct opaqueCMSampleBuffer { } *)a0 bufferEnqueueingInfo:(struct { struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; } x0; struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; } x1; } *)a1;
- (void)_fireDisplayLayerNotificationNowThenReleaseOnMainThread:(id)a0 userInfo:(id)a1;
- (void)_flushComplete;
- (char)_hasEverEnqueued;
- (int)_initializeTimebases;
- (char)_isCreateVideoQueueErrorRetryable:(int)a0;
- (struct OpaqueCMTimebase { } *)_readOnlyVideoQueueTimebase;
- (void)_refreshAboveHighWaterLevel;
- (void)_removeFigVideoQueueListeners;
- (void)_resetStatusWithOSStatus:(int)a0;
- (int)_setContentLayerOnFigVideoQueue:(struct OpaqueFigVideoQueue { } *)a0;
- (void)_setCreateVideoQueueFailedWithOSStatus:(int)a0;
- (void)_setOutputObscuredDueToInsufficientExternalProtection:(char)a0;
- (void)_setRequiresFlushToResumeDecoding:(char)a0;
- (void)_setStatus:(long long)a0 error:(id)a1;
- (char)_setUpcomingPresentationTimeExpectations:(int)a0 minimumPresentationTime:(struct { long long x0; int x1; unsigned int x2; long long x3; })a1;
- (id)_statusString:(long long)a0;
- (void)_updateVideoOutputs;
- (void)addSampleBufferDisplayLayer:(id)a0;
- (int)attachToContentKeySession:(id)a0 contentKeyBoss:(struct OpaqueFigContentKeyBoss { } *)a1 failedSinceAlreadyAttachedToAnotherSession:(char *)a2;
- (char)attachedToExternalContentKeySession;
- (id)contentKeySession;
- (struct __CVBuffer { } *)copyDisplayedPixelBuffer;
- (void)copyFigSampleBufferAudioRenderer:(struct OpaqueFigSampleBufferAudioRenderer **)a0;
- (int)createVideoQueue:(struct OpaqueFigVideoQueue **)a0;
- (id)currentFigVideoQueueFactory;
- (void)enqueueSampleBuffer:(struct opaqueCMSampleBuffer { } *)a0;
- (void)enqueueSampleBuffer:(struct opaqueCMSampleBuffer { } *)a0 bufferEnqueueingInfo:(struct { struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; } x0; struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; } x1; } *)a1;
- (void)expectMinimumUpcomingSampleBufferPresentationTime:(struct { long long x0; int x1; unsigned int x2; long long x3; })a0;
- (void)expectMonotonicallyIncreasingUpcomingSampleBufferPresentationTimes;
- (void)flushAndRemoveImage;
- (void)flushWithRemovalOfDisplayedImage:(char)a0 completionHandler:(id /* block */)a1;
- (char)isReadyForDisplay;
- (void)loadVideoPerformanceMetricsWithCompletionHandler:(id /* block */)a0;
- (void)prerollDecodeWithCompletionHandler:(id /* block */)a0;
- (void)requestMediaDataWhenReadyOnQueue:(id)a0 usingBlock:(id /* block */)a1;
- (void)resetUpcomingSampleBufferPresentationTimeExpectations;
- (void)setContentKeySession:(id)a0;
- (void)setControlTimebase:(struct OpaqueCMTimebase { } *)a0;
- (void)setDisplayLayerVisibility:(char)a0;
- (void)setReadyForDisplayWithoutKVO:(char)a0;
- (char)setRenderSynchronizer:(id)a0 error:(id *)a1;
- (void)setShouldWaitForVideoTarget:(char)a0;
- (char)shouldWaitForVideoTarget;
- (void)stopRequestingMediaData;
- (id)videoPerformanceMetrics;

@end
