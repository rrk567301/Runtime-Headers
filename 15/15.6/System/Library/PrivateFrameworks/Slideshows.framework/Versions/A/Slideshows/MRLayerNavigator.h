@class MCContainer, NSMutableDictionary, MRTransitionChanges, NSMutableSet, MRTransition, MRLayer, NSMutableArray;

@interface MRLayerNavigator : MRLayer {
    MCContainer *mContainer;
    NSMutableDictionary *mSublayersForPlugs;
    MRLayer *mNextSublayer;
    MRLayer *mExtraSublayer;
    MRTransition *mCurrentTransition;
    double mTransitionStartTime;
    double mTransitionDuration;
    MRTransitionChanges *mTransitionChanges;
    double mCurrentSublayerContainerTimeOnTransitionStart;
    double mForcedTransitionProgressOffset;
    char mIsInnerTransitioning;
    char mTransitionIsBackwards;
    char mTransitionWasAborted;
    char mTransitionIsSubzero;
    char mTransitionIsNextPrevious;
    char mTransitionStartedWithNext;
    unsigned char mElementToDraw;
    double mCurrentSublayerInterestingTime;
    double mCurrentSublayerLazyDuration;
    double mCurrentSublayerLazyFactor;
    double mCurrentSublayerAnimationDuration;
    double mNextSublayerInterestingTime;
    double mNextSublayerLazyDuration;
    double mNextSublayerLazyFactor;
    double mNextSublayerAnimationDuration;
    double mTotalMotionDuration;
    unsigned long long mFastScrubbingStartIndex;
    double mFastScrubbingProgress;
    char mIsSerializerBased;
    char mIsInSlideFocusMode;
    char mIsFastScrubbing;
    char mPausedSublayersForTransition;
    char mControlsSublayerTimes;
    char mNeedsToResyncToSerializer;
    char mHasWarnedDelegateAboutNearingEnd;
    MRLayer *mSublayerToPrecompute;
    id mPrecomputingTarget;
    unsigned long long mPrecomputingType;
    NSMutableArray *mHistoryBack;
    NSMutableArray *mHistoryForth;
    NSMutableSet *mPotentialTargetSublayers;
    char mNeedsToUpdatePotentialTargetSublayers;
    char _pauseWhenTransitionEnds;
    double _currentSublayerTheoreticalTimeIn;
    char _needsToRecomputeCurrentSublayerTheoreticalTimeIn;
    double _previouslyRenderedTransitionProgress;
}

@property (readonly) NSMutableArray *sublayers;
@property (readonly) MRLayer *currentSublayer;
@property (readonly) char isTransitioning;
@property char historyIsEnabled;
@property (nonatomic) double forcedTransitionProgress;
@property (readonly) double currentSlideshowTime;

- (void)cleanup;
- (void)activate;
- (void)observeValueForKeyPath:(id)a0 ofObject:(id)a1 change:(id)a2 context:(void *)a3;
- (void)deactivate;
- (char)isInfinite;
- (char)isOpaque;
- (void)setPixelSize:(struct CGSize { double x0; double x1; })a0;
- (id)initWithParameters:(id)a0;
- (char)hasAudio;
- (id)_currentState;
- (double)goBack;
- (char)isAlphaFriendly;
- (id)sublayerForKey:(id)a0;
- (void)synchronizeTime;
- (void)_setNeedsToRequestRebuildAudio:(char)a0;
- (double)fastScrubStart:(id)a0;
- (double)goForth;
- (void)_createExtraSublayer;
- (id)_createSublayerForPlug:(id)a0;
- (id)_createSublayerForPrecomputingWithPlug:(id)a0;
- (void)_deleteSublayer:(id)a0;
- (id)_dumpLayerWithOptions:(unsigned long long)a0;
- (void)_executeLayerCommandQueue;
- (void)_getInterestingTimesForSublayerControl;
- (char)_isNative3D;
- (void)_observePlug;
- (void)_observePlugOnPreactivate;
- (void)_observeSublayer:(id)a0;
- (void)_precomputeAtTime:(double)a0 inContext:(id)a1 withArguments:(id)a2;
- (void)_preprecomputeAtTime:(double)a0 inContext:(id)a1 withArguments:(id)a2;
- (void)_prerenderSublayersAtTime:(double)a0 inContext:(id)a1 withArguments:(id)a2;
- (void)_registerTransitionForHistory:(id)a0 withDestinationPlugID:(id)a1 backwards:(char)a2;
- (void)_removeExtraSublayer;
- (void)_renderAtTime:(double)a0 inContext:(id)a1 withArguments:(id)a2;
- (void)_resyncToSerializerForTime:(double)a0;
- (id)_retainedByUserRenderedImageAtTime:(double)a0 inContext:(id)a1 withArguments:(id)a2;
- (id)_transitionWithTransitionTrigger:(id)a0;
- (void)_unobservePlug;
- (void)_unobservePlugOnDepreactivate;
- (void)_unobserveSublayer:(id)a0;
- (double)abortTransition:(id)a0;
- (double)attemptToFinishTransition:(id)a0 didTransition:(char *)a1 gotReversed:(char *)a2;
- (void)beginMorphingToAspectRatio:(double)a0 withDuration:(double)a1;
- (char)canTransitionToMoreSlides:(char)a0;
- (id)currentSlideInfoForElement:(id)a0;
- (id)currentSlideInfos;
- (void)depreactivate:(char)a0;
- (void)didFocusOnNextSlideWithState:(id)a0;
- (void)didFocusOnPreviousSlideWithState:(id)a0;
- (double)doActionTrigger:(id)a0;
- (double)doTransition:(id)a0 backwards:(char)a1 pzr:(id)a2;
- (double)doTransition:(id)a0 backwards:(char)a1 updateHistory:(char)a2 deltaStartTime:(double)a3 pzr:(id)a4;
- (double)doTransition:(id)a0 withDeltaStartTime:(double)a1;
- (void)endMorphing;
- (void)endMovingCurrentSublayer;
- (void)endTransitionToSublayer;
- (char)enterSlideFocusModeWithState:(id)a0;
- (void)exitSlideFocusModeWithState:(id)a0;
- (double)fastScrubCancel:(id)a0;
- (double)fastScrubEnd:(id)a0;
- (double)fastScrubUpdate:(id)a0;
- (void)fillInNextSlideInformationInState:(id)a0;
- (void)fillInPreviousSlideInformationInState:(id)a0;
- (double)finishTransition:(id)a0;
- (void)getLazyDuration:(double *)a0 lazyFactor:(double *)a1 animationDuration:(double *)a2 fromInterestingTime:(double)a3;
- (char)getStartTime:(double *)a0 andDuration:(double *)a1 forMovingToElementID:(id)a2 backwards:(char)a3;
- (double)gotoMoreSlidesWithAction:(id)a0 backwards:(char)a1 animate:(char)a2 canCatchCurrentTransition:(char)a3;
- (double)gotoNextOrPreviousSlideInCurrentSublayer:(char)a0;
- (double)gotoNextSublayer:(id)a0 animate:(char)a1;
- (double)gotoPreviousSublayer:(id)a0 animate:(char)a1;
- (char)hasMoreSlidesFromTime:(double)a0 backwards:(char)a1 startTime:(double *)a2 duration:(double *)a3;
- (char)hasSlides;
- (char)hasSomethingToRender;
- (id)initWithPlug:(id)a0 andParameters:(id)a1 inSuperlayer:(id)a2;
- (double)interestingTimeForElement:(id)a0;
- (double)interestingTimeForTime:(double)a0;
- (char)isInInteractiveMode;
- (char)isLoadedForTime:(double)a0;
- (void)jumpToNextMarker:(id)a0;
- (void)jumpToPreviousMarker:(id)a0;
- (void)jumpToSublayer:(id)a0 atTime:(double)a1;
- (id)patchworkAtTime:(double)a0 inContext:(id)a1 withArguments:(id)a2;
- (char)prerenderForTime:(double)a0 inContext:(id)a1 withArguments:(id)a2;
- (void)resyncToSerializer;
- (void)setIsInInteractiveMode:(char)a0;
- (void)setSublayer:(id)a0 forKey:(id)a1;
- (double)startMovingCurrentSublayer:(char)a0;
- (id)sublayerForPlugObjectID:(id)a0 recursive:(char)a1;
- (id)sublayerHitAtPoint:(struct CGPoint { double x0; double x1; })a0 onlyIfHitElement:(char)a1 localPoint:(struct CGPoint { double x0; double x1; } *)a2;
- (double)transitionToNextSublayerWithDeltaStartTime:(double)a0;
- (void)updateTransition:(id)a0;
- (char)willFocusOnNextSlideWithState:(id)a0 animate:(char)a1;
- (char)willFocusOnPreviousSlideWithState:(id)a0 animate:(char)a1;

@end
