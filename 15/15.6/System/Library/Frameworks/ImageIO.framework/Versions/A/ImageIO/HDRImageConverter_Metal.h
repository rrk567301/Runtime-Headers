@protocol MTLDevice, MTLBinaryArchive, MTLLibrary, MTLCommandQueue;

@interface HDRImageConverter_Metal : HDRImageConverter

@property (readonly, nonatomic) id<MTLDevice> metalDevice;
@property (readonly, nonatomic) id<MTLCommandQueue> metalCommandQueue;
@property (readonly, nonatomic) id<MTLLibrary> metalLibrary;
@property (readonly, nonatomic) id<MTLBinaryArchive> metalArchive;
@property (readonly, nonatomic) id<MTLBinaryArchive> metalBinaryArchive;
@property (readonly, nonatomic) struct __CVMetalTextureCache { } *metalTextureCache;

+ (id)metalDevice;
+ (id)selectMetalDevice;

- (void)dealloc;
- (id)description;
- (id)init;
- (void).cxx_destruct;
- (char)canUseImageBlocks;
- (char)commitAndWaitUntilCompleted:(id)a0;
- (struct { unsigned long long x0; unsigned long long x1; unsigned long long x2; })computeGridSizeForThreadGroupSize:(struct { unsigned long long x0; unsigned long long x1; unsigned long long x2; })a0 outputSize:(struct { unsigned long long x0; unsigned long long x1; unsigned long long x2; })a1;
- (char)computeLumaGainHistogram:(SEL)a0 scale:(struct { unsigned int x0[32][32]; } *)a1 image:(struct __CVBuffer { } *)a2 transform:(const struct { struct { int x0; struct { } x1; struct { void /* unknown type, empty encoding */ x0[3]; } x2; struct { void /* unknown type, empty encoding */ x0[3]; } x3; } x0; struct { struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; } x0; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x3; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; } x4; } x1; struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x2; } x1; } *)a3 gainMap:(struct __CVBuffer { } *)a4 transform:(const struct { struct { int x0; struct { } x1; struct { void /* unknown type, empty encoding */ x0[3]; } x2; struct { void /* unknown type, empty encoding */ x0[3]; } x3; } x0; struct { struct { int x0; struct { } x1; } x0; struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x1; } x1; } *)a5;
- (struct { unsigned long long x0; unsigned long long x1; unsigned long long x2; })computeThreadGroupSizeForOutputSize:(struct { unsigned long long x0; unsigned long long x1; unsigned long long x2; })a0 pipelineState:(id)a1;
- (id)conversionFunctionWithName:(id)a0 subsampling:(void *)a1;
- (char)convertImage:(struct __CVBuffer { } *)a0 transform:(const struct { struct { int x0; struct { } x1; struct { void /* unknown type, empty encoding */ x0[3]; } x2; struct { void /* unknown type, empty encoding */ x0[3]; } x3; } x0; struct { struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; } x0; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x3; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; } x4; } x1; struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x2; } x1; } *)a1 alternate:(const struct { struct { int x0; struct { } x1; struct { void /* unknown type, empty encoding */ x0[3]; } x2; struct { void /* unknown type, empty encoding */ x0[3]; } x3; } x0; struct { struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; } x0; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x3; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; } x4; } x1; struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x2; } x1; } *)a2 gainMap:(struct __CVBuffer { } *)a3 transform:(const struct { struct { int x0; struct { } x1; struct { void /* unknown type, empty encoding */ x0[3]; } x2; struct { void /* unknown type, empty encoding */ x0[3]; } x3; } x0; struct { struct { int x0; struct { } x1; } x0; struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x1; } x1; } *)a4 alternate:(const struct { struct { int x0; struct { } x1; struct { void /* unknown type, empty encoding */ x0[3]; } x2; struct { void /* unknown type, empty encoding */ x0[3]; } x3; } x0; struct { struct { int x0; struct { } x1; } x0; struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x1; } x1; } *)a5 toImage:(struct __CVBuffer { } *)a6 transform:(const struct { struct { struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x0; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x3; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; } x4; } x1; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; } x2; } x0; struct { int x0; struct { } x1; struct { void /* unknown type, empty encoding */ x0[3]; } x2; } x1; } *)a7 gainMap:(struct __CVBuffer { } *)a8 transform:(const struct { struct { struct { int x0; struct { } x1; } x0; struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x1; BOOL x2; } x0; struct { int x0; struct { } x1; struct { void /* unknown type, empty encoding */ x0[3]; } x2; } x1; } *)a9;
- (char)convertImage:(struct __CVBuffer { } *)a0 transform:(const struct { struct { int x0; struct { } x1; struct { void /* unknown type, empty encoding */ x0[3]; } x2; struct { void /* unknown type, empty encoding */ x0[3]; } x3; } x0; struct { struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; } x0; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x3; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; } x4; } x1; struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x2; } x1; } *)a1 alternate:(const struct { struct { int x0; struct { } x1; struct { void /* unknown type, empty encoding */ x0[3]; } x2; struct { void /* unknown type, empty encoding */ x0[3]; } x3; } x0; struct { struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; } x0; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x3; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; } x4; } x1; struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x2; } x1; } *)a2 toImage:(struct __CVBuffer { } *)a3 transform:(const struct { struct { struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x0; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x3; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; } x4; } x1; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; } x2; } x0; struct { int x0; struct { } x1; struct { void /* unknown type, empty encoding */ x0[3]; } x2; } x1; } *)a4 gainMap:(struct __CVBuffer { } *)a5 transform:(const struct { struct { struct { int x0; struct { } x1; } x0; struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x1; BOOL x2; } x0; struct { int x0; struct { } x1; struct { void /* unknown type, empty encoding */ x0[3]; } x2; } x1; } *)a6;
- (char)convertImage:(struct __CVBuffer { } *)a0 transform:(const struct { struct { int x0; struct { } x1; struct { void /* unknown type, empty encoding */ x0[3]; } x2; struct { void /* unknown type, empty encoding */ x0[3]; } x3; } x0; struct { struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; } x0; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x3; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; } x4; } x1; struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x2; } x1; } *)a1 gainMap:(struct __CVBuffer { } *)a2 transform:(const struct { struct { int x0; struct { } x1; struct { void /* unknown type, empty encoding */ x0[3]; } x2; struct { void /* unknown type, empty encoding */ x0[3]; } x3; } x0; struct { struct { int x0; struct { } x1; } x0; struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x1; } x1; } *)a3 toImage:(struct __CVBuffer { } *)a4 transform:(const struct { struct { struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x0; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x3; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; } x4; } x1; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; } x2; } x0; struct { int x0; struct { } x1; struct { void /* unknown type, empty encoding */ x0[3]; } x2; } x1; } *)a5;
- (char)convertImage:(struct __CVBuffer { } *)a0 transform:(const struct { struct { int x0; struct { } x1; struct { void /* unknown type, empty encoding */ x0[3]; } x2; struct { void /* unknown type, empty encoding */ x0[3]; } x3; } x0; struct { struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; } x0; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x3; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; } x4; } x1; struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x2; } x1; } *)a1 toImage:(struct __CVBuffer { } *)a2 transform:(const struct { struct { struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x0; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x3; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; } x4; } x1; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; } x2; } x0; struct { int x0; struct { } x1; struct { void /* unknown type, empty encoding */ x0[3]; } x2; } x1; } *)a3;
- (void)encodeInputColorTransform:(const struct { struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; } x0; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x3; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; } x4; } x1; struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x2; } *)a0 toBuffer:(id)a1 offset:(unsigned long long)a2 withArgumentEncoder:(id)a3 computeEncoder:(id)a4 index:(unsigned long long)a5;
- (void)encodeInputGainTransform:(const struct { struct { int x0; struct { } x1; } x0; struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x1; } *)a0 toBuffer:(id)a1 offset:(unsigned long long)a2 withArgumentEncoder:(id)a3 computeEncoder:(id)a4 index:(unsigned long long)a5;
- (void)encodeInputImage:(struct __CVBuffer { } *)a0 transform:(const struct { int x0; struct { } x1; struct { void /* unknown type, empty encoding */ x0[3]; } x2; struct { void /* unknown type, empty encoding */ x0[3]; } x3; } *)a1 toBuffer:(id)a2 offset:(unsigned long long)a3 withArgumentEncoder:(id)a4 computeEncoder:(id)a5 index:(unsigned long long)a6 textures:(id)a7;
- (void)encodeOutputColorTransform:(const struct { struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x0; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x3; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; } x4; } x1; struct { int x0; struct { float x0; float x1; float x2; float x3; float x4; float x5; float x6; float x7; } x1; void *x2; } x2; } *)a0 toBuffer:(id)a1 offset:(unsigned long long)a2 withArgumentEncoder:(id)a3 computeEncoder:(id)a4 index:(unsigned long long)a5;
- (void)encodeOutputGainTransform:(const struct { struct { int x0; struct { } x1; } x0; struct { struct { void /* unknown type, empty encoding */ x0[3]; } x0; BOOL x1; } x1; BOOL x2; } *)a0 toBuffer:(id)a1 offset:(unsigned long long)a2 withArgumentEncoder:(id)a3 computeEncoder:(id)a4 index:(unsigned long long)a5;
- (void)encodeOutputImage:(struct __CVBuffer { } *)a0 transform:(const struct { int x0; struct { } x1; struct { void /* unknown type, empty encoding */ x0[3]; } x2; } *)a1 toBuffer:(id)a2 offset:(unsigned long long)a3 withArgumentEncoder:(id)a4 computeEncoder:(id)a5 index:(unsigned long long)a6 textures:(id)a7;
- (char)isPixelFormatSupported:(unsigned int)a0;
- (id)metalBinaryArchiveFileForHarvest;
- (id)metalComputePipelineStateWithFunction:(id)a0;
- (id)metalLibraryFunctionWithName:(id)a0;
- (id)metalLibraryFunctionWithName:(id)a0 functionConstant:(id)a1;
- (unsigned long long)metalPixelFormatForPixelFormat:(unsigned int)a0 plane:(unsigned int)a1;
- (struct __CVBuffer { } *)metalTextureFromBuffer:(struct __CVBuffer { } *)a0 plane:(unsigned int)a1;
- (id)metalTextureFromCubeData:(id)a0;
- (id)metalTextureFromTableData:(id)a0;

@end
