@class NSString, NSArray, PKMetalRenderer, PKStrokeGenerator, NSMutableArray, NSObject, CAMetalLayer, PKMetalConfig, PKLinedPaper;
@protocol MTLTexture, PKMetalRendererControllerDelegate, MTLDevice, CAMetalDrawable, OS_dispatch_semaphore, MTLCommandQueue, OS_dispatch_queue;

@interface PKMetalRendererController : NSObject {
    PKMetalConfig *_metalConfig;
    char _synchronous;
    _Atomic int _cancelLongRunningRenderingCount;
    _Atomic int _cancelAllRendering;
    NSObject<OS_dispatch_semaphore> *_canBeginRenderSemaphore;
    struct atomic_flag { _Atomic BOOL _Value; } _readyToBeginRender;
    _Atomic double _lastFrameDuration;
    _Atomic unsigned long long _lastPresentationTime;
    char _vSyncControllerIsActive;
    _Atomic int _queuedRenders;
    NSMutableArray *_postPresentCallbacks;
    char _isTorndown;
    long long _presentationCount;
    struct PKRunningStat { BOOL isAngle; long long numValues; long long numValuesOverLimit; double oldM; double newM; double oldS; double newS; double minValue; double maxValue; double limit; struct os_unfair_lock_s { unsigned int _os_unfair_lock_opaque; } lock; } _strokeLatencyStat;
    struct PKRunningStat { BOOL isAngle; long long numValues; long long numValuesOverLimit; double oldM; double newM; double oldS; double newS; double minValue; double maxValue; double limit; struct os_unfair_lock_s { unsigned int _os_unfair_lock_opaque; } lock; } _predictedTouchesLatencyStat;
    id<MTLTexture> _currentTextureTarget;
    id<CAMetalDrawable> _currentDrawable;
    id<MTLTexture> _currentMultiplyTextureTarget;
    id<CAMetalDrawable> _currentMultiplyDrawable;
    struct CGImage { } *_paperTextureImage;
    struct CGPoint { double x; double y; } _canvasOffset;
    struct CGAffineTransform { double a; double b; double c; double d; double tx; double ty; } _strokeTransformForRenderQueue;
    id /* block */ _canvasOffsetBlock;
    NSArray *_liveStrokeStrokes;
    struct CGRect { struct CGPoint { double x; double y; } origin; struct CGSize { double width; double height; } size; } _liveStrokeStrokesAnimationBounds;
    char _dirtyRectMightBeInvalid;
    char _renderingForPreview;
    NSString *_currentInkIdentifier;
    double _timestampForDrawingBegan;
    NSObject<OS_dispatch_semaphore> *_updateCycleSemaphore;
    char _isPDFCanvasForAnalytics;
}

@property (retain, nonatomic) PKMetalRenderer *renderer;
@property struct CGAffineTransform { double a; double b; double c; double d; double tx; double ty; } renderTransform;
@property double inputScale;
@property (nonatomic) double _latestLatency;
@property (weak, nonatomic) id<PKMetalRendererControllerDelegate> delegate;
@property (readonly, nonatomic) id<MTLCommandQueue> commandQueue;
@property (readonly, nonatomic) id<MTLDevice> device;
@property (readonly, nonatomic) unsigned long long pixelFormat;
@property (readonly, nonatomic) unsigned long long sixChannelMetalLayerPixelFormat;
@property (readonly, nonatomic) char sixChannelUsesWideGamut;
@property (readonly, nonatomic) NSObject<OS_dispatch_queue> *renderQueue;
@property (nonatomic) struct CGAffineTransform { double a; double b; double c; double d; double tx; double ty; } strokeTransform;
@property (nonatomic) double contentZoomScale;
@property (readonly, nonatomic) PKStrokeGenerator *inputController;
@property (nonatomic) double backboardPaperMultiply;
@property (retain, nonatomic) PKLinedPaper *linedPaper;
@property (nonatomic) struct CGRect { struct CGPoint { double x; double y; } origin; struct CGSize { double width; double height; } size; } viewScissor;
@property (nonatomic) struct CGAffineTransform { double a; double b; double c; double d; double tx; double ty; } paperTransform;
@property (readonly, nonatomic) struct CGSize { double width; double height; } actualSize;
@property (readonly, nonatomic) struct CGSize { double width; double height; } pixelSize;
@property (nonatomic) char liveStrokeMode;
@property (nonatomic) struct CGSize { double width; double height; } liveStrokeMaxSize;
@property (nonatomic) char fadeOutStrokesMode;
@property (nonatomic) double liveStrokeElapsedTime;
@property (nonatomic) double liveStrokeDuration;
@property (weak, nonatomic) CAMetalLayer *presentationLayer;
@property (weak, nonatomic) CAMetalLayer *multiplyPresentationLayer;
@property (nonatomic) char invertColors;
@property (nonatomic) long long sixChannelBlendingMode;
@property (nonatomic) char drawBitmapEraserMask;
@property (nonatomic) char combineStrokesAllowed;
@property (nonatomic) unsigned long long previewStrokeMaxPoints;
@property (nonatomic) double previewStrokeAlpha;
@property (nonatomic) char isPDFCanvasForAnalytics;

- (void)dealloc;
- (void).cxx_destruct;
- (id).cxx_construct;
- (void)clear;
- (void)teardown;
- (void)drawImage:(struct CGImage { } *)a0;
- (void)setBackgroundColor:(struct CGColor { } *)a0;
- (void)setup;
- (void)drawingCancelledWithCompletion:(id /* block */)a0;
- (char)isLongRunningRenderingCancelled;
- (void)drawingEnded:(id)a0 finishStrokeBlock:(id /* block */)a1;
- (unsigned long long)_drawStrokesAfterClear:(id)a0 clippedToStrokeSpaceRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1 strokeTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a2 useLayerContext:(char)a3 progress:(id)a4;
- (void)_drawStrokesAfterClear:(id)a0 clippedToStrokeSpaceRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1 strokeTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a2 useLayerContext:(char)a3 renderCompletion:(id /* block */)a4;
- (void)_logStrokeDuration;
- (void)_present:(double)a0 setDirtyRect:(char)a1;
- (void)_recordStrokeStatistics;
- (void)_recreateMetalRenderer;
- (char)_renderAheadWithTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a0 at:(double)a1;
- (void)_renderAndPresent:(char)a0 withTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a1;
- (void)_renderDrawPoints;
- (void)_renderLiveStrokeAndPresentWithTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a0 at:(double)a1 setDirtyRect:(char)a2;
- (char)_setupCurrentDrawable;
- (void)_updateRendererStrokeTransformWithTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a0 offset:(struct CGPoint { double x0; double x1; })a1;
- (void)addBlockToCallAfterPresenting:(id /* block */)a0;
- (void)addInputPoint:(struct { union { struct CGPoint { double x0; double x1; } x0; struct CGPoint { double x0; double x1; } x1; } x0; double x1; double x2; double x3; double x4; double x5; double x6; double x7; char x8; long long x9; double x10; char x11; double x12; long long x13; long long x14; })a0;
- (void)buildRenderCacheForStrokes:(id)a0;
- (void)callBlockAfterPresenting:(id /* block */)a0;
- (void)callBlockOnRenderQueue:(id /* block */)a0;
- (void)cancelAllRendering;
- (void)cancelLongRunningRenders;
- (void)changeRenderSize;
- (void)didFinishRendering:(id /* block */)a0;
- (void)drawImage:(struct CGImage { } *)a0 clippedToStrokeSpaceRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1;
- (void)drawStrokes:(id)a0 clippedToStrokeSpaceRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1 completion:(id /* block */)a2;
- (void)drawStrokes:(id)a0 completion:(id /* block */)a1;
- (char)drawStrokes:(id)a0 intoTile:(id)a1 renderCount:(long long)a2 offscreen:(char)a3;
- (void)drawStrokesAfterClear:(id)a0 clippedToStrokeSpaceRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1 completion:(id /* block */)a2;
- (void)drawStrokesAfterClear:(id)a0 clippedToStrokeSpaceRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1 strokeTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a2 useLayerContext:(char)a3 completion:(id /* block */)a4;
- (void)drawTexture:(id)a0;
- (void)drawTexture:(id)a0 clippedToStrokeSpaceRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1;
- (void)drawingBeganWithStroke:(id)a0 forPreview:(char)a1;
- (void)drawingCancelledForPreview:(char)a0;
- (void)flushMemoryIfPossible;
- (void)generateSmartFillMaskForStroke:(id)a0 maskPaths:(const void *)a1 completionBlock:(id /* block */)a2;
- (id)initWithPixelSize:(struct CGSize { double x0; double x1; })a0 actualSize:(struct CGSize { double x0; double x1; })a1 metalConfig:(id)a2;
- (id)initWithPixelSize:(struct CGSize { double x0; double x1; })a0 actualSize:(struct CGSize { double x0; double x1; })a1 pixelFormat:(unsigned long long)a2 sixChannelBlendingMode:(long long)a3 metalConfig:(id)a4;
- (char)isAllRenderingCancelled;
- (void)liveStrokeParticlesToFrame:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 strokes:(id)a1 startTime:(double)a2 duration:(double)a3;
- (struct CGImage { } *)newCGImage;
- (struct CGImage { } *)newCGImageWithClipRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
- (void)pokeEventDispatcher;
- (char)prerenderWithTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a0 inputScale:(double)a1 at:(double)a2;
- (void)purgeOriginalBackFramebuffer;
- (void)purgeRenderCachesForStrokes:(id)a0;
- (void)renderImageTexture:(id)a0 imageTextureTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a1 withTiles:(id)a2 tileTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a3;
- (void)renderStrokes:(id)a0 clippedToStrokeSpaceRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1 strokeTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a2 imageClipRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a3 completion:(id /* block */)a4;
- (struct CGImage { } *)renderStrokesSync:(id)a0 clippedToStrokeSpaceRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1 strokeTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a2 imageClipRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a3;
- (void)renderTiles:(id)a0 tileTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a1 clearBackBuffer:(char)a2;
- (void)renderTilesIntoTiles:(id)a0;
- (void)renderWithTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a0 inputScale:(double)a1 at:(double)a2;
- (void)replaceInkTexture:(id)a0 image:(struct CGImage { } *)a1;
- (void)resumeLongRunningRenders;
- (void)resumeLongRunningRendersAfterAllWorkIsDone;
- (void)setAlternativeStrokes:(id)a0 alpha:(double)a1 originalStrokeAlpha:(double)a2;
- (void)setCanvasOffset:(struct CGPoint { double x0; double x1; })a0;
- (void)setCanvasOffsetPresentationOffsetBlock:(id /* block */)a0;
- (void)setLiveRenderingOverrideColor:(struct CGColor { } *)a0;
- (void)setLiveStrokeStrokes:(id)a0 animationBounds:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1;
- (void)setPaperTextureImage:(struct CGImage { } *)a0;
- (void)setPixelSize:(struct CGSize { double x0; double x1; })a0 actualSize:(struct CGSize { double x0; double x1; })a1;
- (void)setResourceCacheSize:(unsigned long long)a0;
- (void)setupSync;
- (void)teardownSync;
- (void)updateCyclePreCACommit:(double)a0 isDrawing:(char)a1;
- (void)updateTiles:(id)a0 withNewStrokes:(id)a1 completionBlock:(id /* block */)a2;

@end
