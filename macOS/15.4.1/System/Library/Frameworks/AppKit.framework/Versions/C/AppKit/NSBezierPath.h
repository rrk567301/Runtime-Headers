@interface NSBezierPath : NSObject <NSCopying, NSSecureCoding> {
    double _lineWidth;
    double _miterLimit;
    double _flatness;
    double *_dashedLinePattern;
    unsigned long long _dashedLineCount;
    double _dashedLinePhase;
    struct CGPath { } *_cgPath;
    struct { unsigned long long x0; struct CGPoint { double x0; double x1; } x1; struct CGPoint { double x0; double x1; } x2; struct CGPoint { double x0; double x1; } x3; } *_localPathCache;
    struct { unsigned char _flags : 8; unsigned char _pathState : 2; unsigned int _unused : 22; } _bpFlags;
}

@property (class) double defaultMiterLimit;
@property (class) double defaultFlatness;
@property (class) unsigned long long defaultWindingRule;
@property (class) unsigned long long defaultLineCapStyle;
@property (class) unsigned long long defaultLineJoinStyle;
@property (class) double defaultLineWidth;
@property (class, readonly) BOOL supportsSecureCoding;

@property (setter=_setCGPath:) struct CGPath { } *_cgPath;
@property struct CGPath { } *CGPath;
@property double lineWidth;
@property unsigned long long lineCapStyle;
@property unsigned long long lineJoinStyle;
@property unsigned long long windingRule;
@property double miterLimit;
@property double flatness;
@property (readonly, copy) NSBezierPath *bezierPathByFlatteningPath;
@property (readonly, copy) NSBezierPath *bezierPathByReversingPath;
@property (readonly, getter=isEmpty) BOOL empty;
@property (readonly) struct CGPoint { double x0; double x1; } currentPoint;
@property (readonly) struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; } controlPointBounds;
@property (readonly) struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; } bounds;
@property (readonly) long long elementCount;

+ (void)initialize;
+ (double)lineWidth;
+ (void)setLineWidth:(double)a0;
+ (void)setWindingRule:(unsigned long long)a0;
+ (id)_bezierPathWithCGPath:(struct CGPath { } *)a0 transform:(id)a1;
+ (id)_bezierPathWithRoundedRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 radius:(double)a1 continuousCorners:(BOOL)a2;
+ (id)bezierPath;
+ (id)bezierPathWithCGPath:(struct CGPath { } *)a0;
+ (id)bezierPathWithOvalInRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (id)bezierPathWithRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (id)bezierPathWithRoundedRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 xRadius:(double)a1 yRadius:(double)a2;
+ (void)clipRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (void)drawPackedGlyphs:(const char *)a0 atPoint:(struct CGPoint { double x0; double x1; })a1;
+ (void)fillRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (double)flatness;
+ (unsigned long long)lineCapStyle;
+ (unsigned long long)lineJoinStyle;
+ (double)miterLimit;
+ (void)setFlatness:(double)a0;
+ (void)setLineCapStyle:(unsigned long long)a0;
+ (void)setLineJoinStyle:(unsigned long long)a0;
+ (void)setMiterLimit:(double)a0;
+ (void)strokeLineFromPoint:(struct CGPoint { double x0; double x1; })a0 toPoint:(struct CGPoint { double x0; double x1; })a1;
+ (void)strokeRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (unsigned long long)windingRule;

- (void)dealloc;
- (id)copyWithZone:(struct _NSZone { } *)a0;
- (id)description;
- (id)init;
- (BOOL)isEqual:(id)a0;
- (void)encodeWithCoder:(id)a0;
- (id)initWithCoder:(id)a0;
- (void)addClip;
- (unsigned long long)elementAtIndex:(long long)a0;
- (void)setClip;
- (struct CGPath { } *)_cgPath;
- (void)appendBezierPathWithOvalInRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
- (void)removeAllPoints;
- (void)_appendArcSegmentWithCenter:(struct CGPoint { double x0; double x1; })a0 radius:(double)a1 angle1:(double)a2 angle2:(double)a3;
- (void)_appendBezierPathWithBottomRoundRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 cornerRadius:(double)a1;
- (void)_appendBezierPathWithContinuousRoundedRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 radius:(double)a1;
- (void)_appendBezierPathWithRoundRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 cornerRadius:(double)a1;
- (void)_appendBezierPathWithTopRoundRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 cornerRadius:(double)a1;
- (void)_appendToPath:(id)a0;
- (id)_copyFlattenedPath;
- (void)_deviceClosePath;
- (void)_deviceCurveToPoint:(struct CGPoint { double x0; double x1; })a0 controlPoint1:(struct CGPoint { double x0; double x1; })a1 controlPoint2:(struct CGPoint { double x0; double x1; })a2;
- (void)_deviceCurveToPoint:(struct CGPoint { double x0; double x1; })a0 controlPoint:(struct CGPoint { double x0; double x1; })a1;
- (void)_deviceLineToPoint:(struct CGPoint { double x0; double x1; })a0;
- (void)_deviceMoveToPoint:(struct CGPoint { double x0; double x1; })a0;
- (void)_enumeratePathElementsUsingBlock:(id /* block */)a0;
- (BOOL)_initializeDashPatternFromDecodedBytes:(const void *)a0 length:(unsigned long long)a1 requiresSecureCoding:(BOOL)a2 error:(id *)a3;
- (BOOL)_initializeSegmentsFromDecodedBytes:(const void *)a0 length:(unsigned long long)a1 requiresSecureCoding:(BOOL)a2 error:(id *)a3;
- (void)appendBezierPath:(id)a0;
- (void)appendBezierPathWithArcFromPoint:(struct CGPoint { double x0; double x1; })a0 toPoint:(struct CGPoint { double x0; double x1; })a1 radius:(double)a2;
- (void)appendBezierPathWithArcWithCenter:(struct CGPoint { double x0; double x1; })a0 radius:(double)a1 startAngle:(double)a2 endAngle:(double)a3;
- (void)appendBezierPathWithArcWithCenter:(struct CGPoint { double x0; double x1; })a0 radius:(double)a1 startAngle:(double)a2 endAngle:(double)a3 clockwise:(BOOL)a4;
- (void)appendBezierPathWithCGGlyph:(unsigned short)a0 inFont:(id)a1;
- (void)appendBezierPathWithCGGlyphs:(const unsigned short *)a0 count:(long long)a1 inFont:(id)a2;
- (void)appendBezierPathWithCGPath:(struct CGPath { } *)a0;
- (void)appendBezierPathWithGlyph:(unsigned int)a0 inFont:(id)a1;
- (void)appendBezierPathWithGlyphs:(unsigned int *)a0 count:(long long)a1 inFont:(id)a2;
- (void)appendBezierPathWithNativeGlyphs:(const unsigned short *)a0 advances:(struct CGSize { double x0; double x1; } *)a1 count:(unsigned long long)a2 inFont:(id)a3;
- (void)appendBezierPathWithPackedGlyphs:(const char *)a0;
- (void)appendBezierPathWithPoints:(struct CGPoint { double x0; double x1; } *)a0 count:(long long)a1;
- (void)appendBezierPathWithRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
- (void)appendBezierPathWithRoundedRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 xRadius:(double)a1 yRadius:(double)a2;
- (BOOL)cachesBezierPath;
- (void)closePath;
- (BOOL)containsPoint:(struct CGPoint { double x0; double x1; })a0;
- (void)curveToPoint:(struct CGPoint { double x0; double x1; })a0 controlPoint1:(struct CGPoint { double x0; double x1; })a1 controlPoint2:(struct CGPoint { double x0; double x1; })a2;
- (void)curveToPoint:(struct CGPoint { double x0; double x1; })a0 controlPoint:(struct CGPoint { double x0; double x1; })a1;
- (unsigned long long)elementAtIndex:(long long)a0 associatedPoints:(struct CGPoint { double x0; double x1; } *)a1;
- (void)fill;
- (void)flattenIntoPath:(id)a0;
- (void)getLineDash:(double *)a0 count:(long long *)a1 phase:(double *)a2;
- (void)lineToPoint:(struct CGPoint { double x0; double x1; })a0;
- (void)moveToPoint:(struct CGPoint { double x0; double x1; })a0;
- (void)relativeCurveToPoint:(struct CGPoint { double x0; double x1; })a0 controlPoint1:(struct CGPoint { double x0; double x1; })a1 controlPoint2:(struct CGPoint { double x0; double x1; })a2;
- (void)relativeCurveToPoint:(struct CGPoint { double x0; double x1; })a0 controlPoint:(struct CGPoint { double x0; double x1; })a1;
- (void)relativeLineToPoint:(struct CGPoint { double x0; double x1; })a0;
- (void)relativeMoveToPoint:(struct CGPoint { double x0; double x1; })a0;
- (void)setAssociatedPoints:(struct CGPoint { double x0; double x1; } *)a0 atIndex:(long long)a1;
- (void)setCachesBezierPath:(BOOL)a0;
- (void)setLineDash:(const double *)a0 count:(long long)a1 phase:(double)a2;
- (void)stroke;
- (void)transformUsingAffineTransform:(id)a0;

@end
