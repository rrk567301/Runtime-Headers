@interface TSUBezierPath : NSObject <NSCopying> {
    long long sfr_elementCount;
    long long sfr_elementMax;
    struct PATHSEGMENT { unsigned char x0 : 4; unsigned long x1 : 60; struct CGPoint { double x0; double x1; } x2; } *sfr_head;
    double *sfr_elementLength;
    double sfr_totalLength;
    long long sfr_lastSubpathIndex;
    void *sfr_extraSegments;
    double sfr_lineWidth;
    struct CGRect { struct CGPoint { double x; double y; } origin; struct CGSize { double width; double height; } size; } sfr_bounds;
    struct CGRect { struct CGPoint { double x; double y; } origin; struct CGSize { double width; double height; } size; } sfr_controlPointBounds;
    double sfr_miterLimit;
    double sfr_flatness;
    double *sfr_dashedLinePattern;
    unsigned long long sfr_dashedLineCount;
    double sfr_dashedLinePhase;
    struct CGPath { } *sfr_path;
    long long sfr_extraSegmentCount;
    long long sfr_extraSegmentMax;
    struct { unsigned char sfr_flags : 8; unsigned char sfr_pathState : 2; unsigned char sfr_calculatedLengths : 1; unsigned int sfr_unused : 21; } sfr_bpFlags;
}

@property (nonatomic) double lineWidth;
@property (nonatomic) unsigned long long lineCapStyle;
@property (nonatomic) unsigned long long lineJoinStyle;
@property (nonatomic) long long windingRule;
@property (nonatomic) double miterLimit;
@property (nonatomic) double flatness;
@property (readonly, nonatomic) struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; } bounds;
@property (readonly, nonatomic) BOOL containsClosePathElement;

+ (void)initialize;
+ (double)lineWidth;
+ (void)setLineWidth:(double)a0;
+ (double)defaultFlatness;
+ (void)setWindingRule:(long long)a0;
+ (id)bezierPath;
+ (id)bezierPathWithCGPath:(struct CGPath { } *)a0;
+ (id)bezierPathWithOvalInRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (id)bezierPathWithRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (void)clipRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (unsigned long long)defaultLineCapStyle;
+ (unsigned long long)defaultLineJoinStyle;
+ (double)defaultLineWidth;
+ (double)defaultMiterLimit;
+ (long long)defaultWindingRule;
+ (void)fillRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (double)flatness;
+ (unsigned long long)lineCapStyle;
+ (unsigned long long)lineJoinStyle;
+ (double)miterLimit;
+ (void)setDefaultFlatness:(double)a0;
+ (void)setDefaultLineCapStyle:(unsigned long long)a0;
+ (void)setDefaultLineJoinStyle:(unsigned long long)a0;
+ (void)setDefaultLineWidth:(double)a0;
+ (void)setDefaultMiterLimit:(double)a0;
+ (void)setDefaultWindingRule:(long long)a0;
+ (void)setFlatness:(double)a0;
+ (void)setLineCapStyle:(unsigned long long)a0;
+ (void)setLineJoinStyle:(unsigned long long)a0;
+ (void)setMiterLimit:(double)a0;
+ (void)strokeLineFromPoint:(struct CGPoint { double x0; double x1; })a0 toPoint:(struct CGPoint { double x0; double x1; })a1;
+ (void)strokeRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (long long)windingRule;
+ (id)bezierPathWithStart:(struct CGPoint { double x0; double x1; })a0 end:(struct CGPoint { double x0; double x1; })a1;
+ (id)bezierPathWithLegacyRoundedRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 cornerRadius:(double)a1;
+ (id)bezierPathWithRoundedRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 upperRightRadius:(double)a1 lowerRightRadius:(double)a2 lowerLeftRadius:(double)a3 upperLeftRadius:(double)a4 useLegacyCorners:(BOOL)a5 keepNoOpElements:(BOOL)a6;
+ (id)bezierPathWithDefaultsForErrorCases;
+ (id)bezierPathWithContinuousCornerRoundedRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 cornerRadius:(double)a1;
+ (double)minimumLengthForSideToHaveFullContinuityWithCornerRadius1:(double)a0 cornerRadius2:(double)a1;

- (void)dealloc;
- (id)copyWithZone:(struct _NSZone { } *)a0;
- (id)description;
- (unsigned long long)hash;
- (id)init;
- (BOOL)isEqual:(id)a0;
- (double)length;
- (const char *)cString;
- (BOOL)isEmpty;
- (id)initWithCString:(const char *)a0;
- (struct CGPath { } *)CGPath;
- (void)addClip;
- (long long)elementAtIndex:(long long)a0;
- (void)appendBezierPathWithOvalInRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
- (void)removeAllPoints;
- (void)_appendArcSegmentWithCenter:(struct CGPoint { double x0; double x1; })a0 radius:(double)a1 angle1:(double)a2 angle2:(double)a3;
- (id)_copyFlattenedPath;
- (void)_deviceClosePath;
- (void)_deviceCurveToPoint:(struct CGPoint { double x0; double x1; })a0 controlPoint1:(struct CGPoint { double x0; double x1; })a1 controlPoint2:(struct CGPoint { double x0; double x1; })a2;
- (void)_deviceLineToPoint:(struct CGPoint { double x0; double x1; })a0;
- (void)_deviceMoveToPoint:(struct CGPoint { double x0; double x1; })a0;
- (void)appendBezierPath:(id)a0;
- (void)appendBezierPathWithArcFromPoint:(struct CGPoint { double x0; double x1; })a0 toPoint:(struct CGPoint { double x0; double x1; })a1 radius:(double)a2;
- (void)appendBezierPathWithArcWithCenter:(struct CGPoint { double x0; double x1; })a0 radius:(double)a1 startAngle:(double)a2 endAngle:(double)a3;
- (void)appendBezierPathWithArcWithCenter:(struct CGPoint { double x0; double x1; })a0 radius:(double)a1 startAngle:(double)a2 endAngle:(double)a3 clockwise:(BOOL)a4;
- (void)appendBezierPathWithPoints:(struct CGPoint { double x0; double x1; } *)a0 count:(long long)a1;
- (void)appendBezierPathWithRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
- (id)bezierPathByFlatteningPath;
- (id)bezierPathByReversingPath;
- (void)closePath;
- (BOOL)containsPoint:(struct CGPoint { double x0; double x1; })a0;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })controlPointBounds;
- (struct CGPoint { double x0; double x1; })currentPoint;
- (void)curveToPoint:(struct CGPoint { double x0; double x1; })a0 controlPoint1:(struct CGPoint { double x0; double x1; })a1 controlPoint2:(struct CGPoint { double x0; double x1; })a2;
- (void)curveToPoint:(struct CGPoint { double x0; double x1; })a0 controlPoint:(struct CGPoint { double x0; double x1; })a1;
- (long long)elementAtIndex:(long long)a0 associatedPoints:(struct CGPoint { double x0; double x1; } *)a1;
- (long long)elementCount;
- (void)fill;
- (void)flattenIntoPath:(id)a0;
- (void)getLineDash:(double *)a0 count:(long long *)a1 phase:(double *)a2;
- (BOOL)isRectangular;
- (void)lineToPoint:(struct CGPoint { double x0; double x1; })a0;
- (void)moveToPoint:(struct CGPoint { double x0; double x1; })a0;
- (void)relativeCurveToPoint:(struct CGPoint { double x0; double x1; })a0 controlPoint1:(struct CGPoint { double x0; double x1; })a1 controlPoint2:(struct CGPoint { double x0; double x1; })a2;
- (void)relativeCurveToPoint:(struct CGPoint { double x0; double x1; })a0 controlPoint:(struct CGPoint { double x0; double x1; })a1;
- (void)relativeLineToPoint:(struct CGPoint { double x0; double x1; })a0;
- (void)relativeMoveToPoint:(struct CGPoint { double x0; double x1; })a0;
- (void)setAssociatedPoints:(struct CGPoint { double x0; double x1; } *)a0 atIndex:(long long)a1;
- (void)setLineDash:(const double *)a0 count:(long long)a1 phase:(double)a2;
- (void)stroke;
- (void)transformUsingAffineTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a0;
- (BOOL)_isValid:(double)a0;
- (void)_doPath;
- (void)_addPathSegment:(long long)a0 point:(struct CGPoint { double x0; double x1; })a1;
- (void)_appendToPath:(id)a0 skippingInitialMoveIfPossible:(BOOL)a1;
- (struct CGPoint { double x0; double x1; })_checkPointForValidity:(struct CGPoint { double x0; double x1; })a0;
- (void)appendBezierPath:(id)a0 skippingInitialMoveIfPossible:(BOOL)a1;
- (void)appendBezierPathWithArcWithEllipseBounds:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 startAngle:(double)a1 swingAngle:(double)a2 angleType:(int)a3 startNewPath:(BOOL)a4;
- (void)appendBezierPathWithArcWithEllipseBounds:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 startRadialVector:(struct CGPoint { double x0; double x1; })a1 endRadialVector:(struct CGPoint { double x0; double x1; })a2 angleSign:(int)a3 startNewPath:(BOOL)a4;
- (id)bezierPathByFlatteningPathWithFlatness:(double)a0;
- (id)bezierPathByRemovingRedundantElements;
- (id)bezierPathByRemovingSmallSubpathsForInteriorWrapsForInset:(double)a0;
- (double)calculateLengthOfElement:(long long)a0;
- (void)calculateLengths;
- (void)copyPathAttributesTo:(id)a0;
- (long long)elementAtIndex:(long long)a0 allPoints:(struct CGPoint { double x0; double x1; } *)a1;
- (void)flattenIntoPath:(id)a0 flatness:(double)a1;
- (BOOL)isCircular;
- (BOOL)isClockwise;
- (BOOL)isDiamond;
- (BOOL)isFlat;
- (BOOL)isTriangular;
- (double)lengthOfElement:(long long)a0;
- (double)lengthToElement:(long long)a0;
- (id)p_bezierPathByRemovingRedundantElementAndSubregionsSmallerThanThreshold:(double)a0;
- (void)subdivideBezierWithFlatness:(double)a0 startPoint:(struct CGPoint { double x0; double x1; })a1 controlPoint1:(struct CGPoint { double x0; double x1; })a2 controlPoint2:(struct CGPoint { double x0; double x1; })a3 endPoint:(struct CGPoint { double x0; double x1; })a4;
- (void)convertCloseElementsToLineElements;

@end
