@class NSData, CCIntermediateData, CCPass, NSObject, CCContext, MTLRasterizationRateMapDescriptor, CP_OBJECT_cp_swapchain_link, CP_OBJECT_cp_swapchain, CP_OBJECT_cp_layer_renderer_properties, CCLane, CP_OBJECT_cp_layer_renderer_capabilities, MTLSharedEventListener, CCRasterizationRateMapState, CP_OBJECT_cp_layer_renderer_configuration, NSArray, NSXPCConnection, CP_OBJECT_drawable_render_context_impl, CCAccelerateDeviceGroup;
@protocol MTLCommandBuffer, WBLayer, MTLSharedEvent, MTLDevice, MTL4CommandQueue, MTLTexture, OS_ar_device_anchor, MTL4CommandBuffer, MTLRasterizationRateMapSPI, MTLCommandBufferSPI, MTLBuffer, MTLEvent, OS_channel_rt, MTLCommandQueue;

@interface CP_OBJECT_cp_layer_renderer : NSObject {
    CP_OBJECT_cp_layer_renderer_configuration *_configuration;
    CP_OBJECT_cp_layer_renderer_capabilities *_capabilities;
    NSObject<OS_channel_rt> *_channel;
    struct { struct os_unfair_lock_s { unsigned int _os_unfair_lock_opaque; } read; struct os_unfair_lock_s { unsigned int _os_unfair_lock_opaque; } write; } _channel_locks;
    NSXPCConnection *_connection;
    NSXPCConnection *_post_process_connection;
    NSObject<OS_channel_rt> *_post_process_channel;
    id<WBLayer> _remote_post_process_layer;
    BOOL _is_post_process_being_debugged;
    struct cp_layer_events { id<MTLSharedEvent> did_app_only_render; id<MTLSharedEvent> did_all_render; } _events;
    MTLSharedEventListener *_completion_listener;
    struct { struct cp_cc_context { CCContext *_on_render_finish_context; CCLane *_output_data_lane; CCLane *_input_xr_lane; CCLane *_input_warp_algorithm_lane; CCLane *_input_taa_algorithm_lane; CCLane *_input_adaptive_registration_lane; CCAccelerateDeviceGroup *_on_render_finish_device_group; id<MTLCommandQueue> _cmd_queue; id<MTLEvent> _sync_event; CCPass *_on_render_finish_pass; } _maybe_uninitialized_storage; struct cp_cc_context *or_null; } _cc_context;
    struct cp_frame_pool { CP_OBJECT_cp_layer_renderer *_layer; unsigned long long _current_index; struct cp_frame { CP_OBJECT_cp_layer_renderer *layer; unsigned char state; struct cp_frame_signpost_timing { struct continuous_time_t { unsigned long long mct; } query_frame; struct continuous_time_t { unsigned long long mct; } predict_timing; struct continuous_time_interval { struct continuous_time_t { unsigned long long mct; } begin; struct continuous_time_t { unsigned long long mct; } end; } update_interval; struct continuous_time_interval { struct continuous_time_t { unsigned long long mct; } begin; struct continuous_time_t { unsigned long long mct; } end; } submission_interval; struct continuous_time_interval { struct continuous_time_t { unsigned long long mct; } begin; struct continuous_time_t { unsigned long long mct; } end; } query_drawable; struct cp_time { unsigned long long cp_mach_abs_time; } presentation_time; struct cp_time { unsigned long long cp_mach_abs_time; } optimal_input_time; } signpost_timings; struct cp_frame_metadata { unsigned long long frame_index; struct WBDCalibrationData { void /* unknown type, empty encoding */ tangents[2]; struct { void /* unknown type, empty encoding */ columns[4]; } render_to_device_transform[2]; struct { void /* unknown type, empty encoding */ columns[4]; } device_to_render_transform[2]; struct { void /* unknown type, empty encoding */ columns[4]; } adaptive_registration_render_to_device_rub_transform[2]; struct { void /* unknown type, empty encoding */ columns[4]; } adaptive_registration_homography[2]; struct { void /* unknown type, empty encoding */ columns[4]; } device_to_disp_transform[2]; struct { void /* unknown type, empty encoding */ columns[4]; } disp_to_device_transform[2]; struct { void /* unknown type, empty encoding */ tangents[2]; struct { void /* unknown type, empty encoding */ columns[4]; } render_to_device_rub_transform[2]; int composited_eye_index; BOOL is_stereo; } recorder; } calibration; struct cp_frame_timing *frame_timing; long long warp_algorithm; long long adaptive_registration_mode; struct WBFoveationVRRRecommendation { unsigned int mode; struct { float gaze_uncertainty; float min_ppd; float max_ppd; } eye[2]; void /* unknown type, empty encoding */ gaze_tan_angle[2]; void /* unknown type, empty encoding */ edge_tiles_ppd; BOOL use_constant_cr; } foveation_recommendation; BOOL is_legacy_high_quality; struct RTPose { struct { void /* unknown type, empty encoding */ columns[4]; } device_to_world; struct { void /* unknown type, empty encoding */ columns[4]; } world_to_device; struct { void /* unknown type, empty encoding */ columns[4]; } neck_to_device; int initialization_id; unsigned long long session_id; double target_timestamp; double query_timestamp; double last_inertial_timestamp; BOOL vio_could_be_in_a_bad_state; unsigned char type; } recording_pose_or_invalid; BOOL allows_capture_protected_content; unsigned int immersion_style; BOOL requires_recorder; } frame_metadata; struct cp_drawable_array { struct cp_drawable *drawables[2]; unsigned long long count; } drawable_array; } _frames[3]; } _frame_pool;
    struct cp_drawable_pool { CP_OBJECT_cp_layer_renderer *_layer; unsigned long long _drawable_count; unsigned long long _current_index; struct cp_drawable { CP_OBJECT_cp_layer_renderer *_layer; unsigned long long _pool_index; unsigned int _state; BOOL should_block_rendering_until_next_chainlink_swap; CP_OBJECT_cp_swapchain_link *_chainlink_storage_access_only; unsigned long long _chainlink_id; struct { unsigned long long texture_count; unsigned long long tracking_areas_texture_count; id<MTLTexture> color_textures[2]; id<MTLTexture> depth_textures[2]; id<MTLTexture> tracking_areas_textures[2]; id<MTLBuffer> vrr_buffers[2]; struct { CCIntermediateData *intermediate_data; NSArray *depth_bins; } _cc_pose_independent_data; struct cp_texture_properties *texture_properties; } _chainlink_properties; unsigned long long _view_count; struct cp_view { struct { void /* unknown type, empty encoding */ columns[4]; } _transform; struct { void /* unknown type, empty encoding */ client; void /* unknown type, empty encoding */ compositor; } _tangents; struct cp_view_texture_map { unsigned long long _texture_index; unsigned long long _slice_index; struct { double originX; double originY; double width; double height; double znear; double zfar; } _viewport; } _texture_map; struct CCOccupancyPacked { void /* unknown type, empty encoding */ dimensions; void /* unknown type, empty encoding */ occupancy; } _rendered_occupancy; struct { struct { double originX; double originY; double width; double height; double znear; double zfar; } viewport; BOOL is_set; } _rendered_bounding_box_viewport; BOOL _can_use_tangents; } _views[2]; struct { struct { void /* unknown type, empty encoding */ columns[4]; } transform[2]; BOOL queried; } _projection_matrix; NSObject<OS_ar_device_anchor> *_device_anchor; BOOL _is_headlocked; void /* unknown type, empty encoding */ _depth_range; BOOL _depth_written_forward; float _constant_depth_value; BOOL _wants_obfuscated_cloned_display; BOOL _content_capture_protected; struct { struct cp_tracking_area *buffer; unsigned short size; unsigned short hover_effect_count; } _tracking_areas; struct cp_frame_metadata { unsigned long long frame_index; struct WBDCalibrationData { void /* unknown type, empty encoding */ tangents[2]; struct { void /* unknown type, empty encoding */ columns[4]; } render_to_device_transform[2]; struct { void /* unknown type, empty encoding */ columns[4]; } device_to_render_transform[2]; struct { void /* unknown type, empty encoding */ columns[4]; } adaptive_registration_render_to_device_rub_transform[2]; struct { void /* unknown type, empty encoding */ columns[4]; } adaptive_registration_homography[2]; struct { void /* unknown type, empty encoding */ columns[4]; } device_to_disp_transform[2]; struct { void /* unknown type, empty encoding */ columns[4]; } disp_to_device_transform[2]; struct { void /* unknown type, empty encoding */ tangents[2]; struct { void /* unknown type, empty encoding */ columns[4]; } render_to_device_rub_transform[2]; int composited_eye_index; BOOL is_stereo; } recorder; } calibration; struct cp_frame_timing *frame_timing; long long warp_algorithm; long long adaptive_registration_mode; struct WBFoveationVRRRecommendation { unsigned int mode; struct { float gaze_uncertainty; float min_ppd; float max_ppd; } eye[2]; void /* unknown type, empty encoding */ gaze_tan_angle[2]; void /* unknown type, empty encoding */ edge_tiles_ppd; BOOL use_constant_cr; } foveation_recommendation; BOOL is_legacy_high_quality; struct RTPose { struct { void /* unknown type, empty encoding */ columns[4]; } device_to_world; struct { void /* unknown type, empty encoding */ columns[4]; } world_to_device; struct { void /* unknown type, empty encoding */ columns[4]; } neck_to_device; int initialization_id; unsigned long long session_id; double target_timestamp; double query_timestamp; double last_inertial_timestamp; BOOL vio_could_be_in_a_bad_state; unsigned char type; } recording_pose_or_invalid; BOOL allows_capture_protected_content; unsigned int immersion_style; BOOL requires_recorder; } _frame_metadata; struct cp_frame_timing { struct RTVSync { unsigned long long id; unsigned long long system_id; struct abs_time_t { unsigned long long mabs; } suspending_time; struct continuous_time_t { unsigned long long mct; } continuous_time; struct mach_duration_t { long long value; } duration; } initial_predicted_vsync; struct RTVSync { unsigned long long id; unsigned long long system_id; struct abs_time_t { unsigned long long mabs; } suspending_time; struct continuous_time_t { unsigned long long mct; } continuous_time; struct mach_duration_t { long long value; } duration; } target_vsync; struct mach_duration_t { long long value; } application_frame_interval; unsigned long long frame_repeat_count; struct mach_duration_t { long long value; } running_start; struct mach_duration_t { long long value; } compositor_overhead; double target_vsync_to_presentation_time_offset; double target_vsync_to_mcam_time_offset; struct WBHMDContentModeTransition { unsigned char mode; struct abs_time_t { unsigned long long mabs; } completion_time; } content_mode; unsigned long long index; struct { struct WBHMDRemoteCompositorClientStats { struct abs_time_t { unsigned long long mabs; } query_frame_time; struct mach_duration_t { long long value; } client_to_server_latency; } _do_not_access_value; struct _RTOptionalBase { BOOL has_value; } _do_not_access_base; } client_stats; } _storage_only_recorder_frame_timing; struct continuous_time_interval { struct continuous_time_t { unsigned long long mct; } begin; struct continuous_time_t { unsigned long long mct; } end; } _signpost_timing_present; unsigned long long _synchronization_frame_index; unsigned long long _rasterization_rate_map_count; id<MTLRasterizationRateMapSPI> _rasterization_rate_maps[2]; id<MTLRasterizationRateMapSPI> _rasterization_rate_maps_flipped[2]; MTLRasterizationRateMapDescriptor *_rasterization_rate_map_descriptors[2]; MTLRasterizationRateMapDescriptor *_rasterization_rate_map_descriptors_flipped[2]; CCRasterizationRateMapState *_cc_rasterization_rate_map_state[2]; struct WBVRRContext *_vrr_context; float _previous_max_ppd; id<MTLTexture> _cc_color_texture_as_2darray[2]; id<MTLTexture> _cc_depth_texture_as_2darray[2]; id<MTLCommandBufferSPI> _cc_command_buffer; struct cp_drawable_render_context { int _state; id<MTLCommandBuffer> _command_buffer; struct { id<MTL4CommandBuffer> buffer; unsigned long long generation; } _command_buffer4; struct cp_drawable *_drawable; CP_OBJECT_drawable_render_context_impl *_renderer; long long _resource_id; } _render_context; } _drawables[6]; } _drawable_pool;
    struct cp_pacing_controller { CP_OBJECT_cp_layer_renderer *_layer; long long _current_index; struct cp_frame_timing { struct RTVSync { unsigned long long id; unsigned long long system_id; struct abs_time_t { unsigned long long mabs; } suspending_time; struct continuous_time_t { unsigned long long mct; } continuous_time; struct mach_duration_t { long long value; } duration; } initial_predicted_vsync; struct RTVSync { unsigned long long id; unsigned long long system_id; struct abs_time_t { unsigned long long mabs; } suspending_time; struct continuous_time_t { unsigned long long mct; } continuous_time; struct mach_duration_t { long long value; } duration; } target_vsync; struct mach_duration_t { long long value; } application_frame_interval; unsigned long long frame_repeat_count; struct mach_duration_t { long long value; } running_start; struct mach_duration_t { long long value; } compositor_overhead; double target_vsync_to_presentation_time_offset; double target_vsync_to_mcam_time_offset; struct WBHMDContentModeTransition { unsigned char mode; struct abs_time_t { unsigned long long mabs; } completion_time; } content_mode; unsigned long long index; struct { struct WBHMDRemoteCompositorClientStats { struct abs_time_t { unsigned long long mabs; } query_frame_time; struct mach_duration_t { long long value; } client_to_server_latency; } _do_not_access_value; struct _RTOptionalBase { BOOL has_value; } _do_not_access_base; } client_stats; } _frames[7]; struct { struct pacing_predictor { struct kalman_filter_predictor { double variance_from_estimate_ns; double process_noise_variance_ns; struct nano_duration_t { long long nanos; } prediction; } predictor; struct predictor_stats { struct samples_queue { long long samples[100]; unsigned long long count; int head; int tail; } samples; double variance; double sum; double mean; } _stats; } _maybe_uninitialized_storage; struct pacing_predictor *or_null; } _pacing_predictor; } _pacing_controller;
    CP_OBJECT_cp_swapchain *_swapchain;
    struct cp_layer_recorder { CP_OBJECT_cp_swapchain *swapchain; struct { struct cp_cc_context { CCContext *_on_render_finish_context; CCLane *_output_data_lane; CCLane *_input_xr_lane; CCLane *_input_warp_algorithm_lane; CCLane *_input_taa_algorithm_lane; CCLane *_input_adaptive_registration_lane; CCAccelerateDeviceGroup *_on_render_finish_device_group; id<MTLCommandQueue> _cmd_queue; id<MTLEvent> _sync_event; CCPass *_on_render_finish_pass; } _maybe_uninitialized_storage; struct cp_cc_context *or_null; } cc_context; struct cp_drawable_pool { CP_OBJECT_cp_layer_renderer *_layer; unsigned long long _drawable_count; unsigned long long _current_index; struct cp_drawable { CP_OBJECT_cp_layer_renderer *_layer; unsigned long long _pool_index; unsigned int _state; BOOL should_block_rendering_until_next_chainlink_swap; CP_OBJECT_cp_swapchain_link *_chainlink_storage_access_only; unsigned long long _chainlink_id; struct { unsigned long long texture_count; unsigned long long tracking_areas_texture_count; id<MTLTexture> color_textures[2]; id<MTLTexture> depth_textures[2]; id<MTLTexture> tracking_areas_textures[2]; id<MTLBuffer> vrr_buffers[2]; struct { CCIntermediateData *intermediate_data; NSArray *depth_bins; } _cc_pose_independent_data; struct cp_texture_properties *texture_properties; } _chainlink_properties; unsigned long long _view_count; struct cp_view { struct { void /* unknown type, empty encoding */ columns[4]; } _transform; struct { void /* unknown type, empty encoding */ client; void /* unknown type, empty encoding */ compositor; } _tangents; struct cp_view_texture_map { unsigned long long _texture_index; unsigned long long _slice_index; struct { double originX; double originY; double width; double height; double znear; double zfar; } _viewport; } _texture_map; struct CCOccupancyPacked { void /* unknown type, empty encoding */ dimensions; void /* unknown type, empty encoding */ occupancy; } _rendered_occupancy; struct { struct { double originX; double originY; double width; double height; double znear; double zfar; } viewport; BOOL is_set; } _rendered_bounding_box_viewport; BOOL _can_use_tangents; } _views[2]; struct { struct { void /* unknown type, empty encoding */ columns[4]; } transform[2]; BOOL queried; } _projection_matrix; NSObject<OS_ar_device_anchor> *_device_anchor; BOOL _is_headlocked; void /* unknown type, empty encoding */ _depth_range; BOOL _depth_written_forward; float _constant_depth_value; BOOL _wants_obfuscated_cloned_display; BOOL _content_capture_protected; struct { struct cp_tracking_area *buffer; unsigned short size; unsigned short hover_effect_count; } _tracking_areas; struct cp_frame_metadata { unsigned long long frame_index; struct WBDCalibrationData { void /* unknown type, empty encoding */ tangents[2]; struct { void /* unknown type, empty encoding */ columns[4]; } render_to_device_transform[2]; struct { void /* unknown type, empty encoding */ columns[4]; } device_to_render_transform[2]; struct { void /* unknown type, empty encoding */ columns[4]; } adaptive_registration_render_to_device_rub_transform[2]; struct { void /* unknown type, empty encoding */ columns[4]; } adaptive_registration_homography[2]; struct { void /* unknown type, empty encoding */ columns[4]; } device_to_disp_transform[2]; struct { void /* unknown type, empty encoding */ columns[4]; } disp_to_device_transform[2]; struct { void /* unknown type, empty encoding */ tangents[2]; struct { void /* unknown type, empty encoding */ columns[4]; } render_to_device_rub_transform[2]; int composited_eye_index; BOOL is_stereo; } recorder; } calibration; struct cp_frame_timing *frame_timing; long long warp_algorithm; long long adaptive_registration_mode; struct WBFoveationVRRRecommendation { unsigned int mode; struct { float gaze_uncertainty; float min_ppd; float max_ppd; } eye[2]; void /* unknown type, empty encoding */ gaze_tan_angle[2]; void /* unknown type, empty encoding */ edge_tiles_ppd; BOOL use_constant_cr; } foveation_recommendation; BOOL is_legacy_high_quality; struct RTPose { struct { void /* unknown type, empty encoding */ columns[4]; } device_to_world; struct { void /* unknown type, empty encoding */ columns[4]; } world_to_device; struct { void /* unknown type, empty encoding */ columns[4]; } neck_to_device; int initialization_id; unsigned long long session_id; double target_timestamp; double query_timestamp; double last_inertial_timestamp; BOOL vio_could_be_in_a_bad_state; unsigned char type; } recording_pose_or_invalid; BOOL allows_capture_protected_content; unsigned int immersion_style; BOOL requires_recorder; } _frame_metadata; struct cp_frame_timing { struct RTVSync { unsigned long long id; unsigned long long system_id; struct abs_time_t { unsigned long long mabs; } suspending_time; struct continuous_time_t { unsigned long long mct; } continuous_time; struct mach_duration_t { long long value; } duration; } initial_predicted_vsync; struct RTVSync { unsigned long long id; unsigned long long system_id; struct abs_time_t { unsigned long long mabs; } suspending_time; struct continuous_time_t { unsigned long long mct; } continuous_time; struct mach_duration_t { long long value; } duration; } target_vsync; struct mach_duration_t { long long value; } application_frame_interval; unsigned long long frame_repeat_count; struct mach_duration_t { long long value; } running_start; struct mach_duration_t { long long value; } compositor_overhead; double target_vsync_to_presentation_time_offset; double target_vsync_to_mcam_time_offset; struct WBHMDContentModeTransition { unsigned char mode; struct abs_time_t { unsigned long long mabs; } completion_time; } content_mode; unsigned long long index; struct { struct WBHMDRemoteCompositorClientStats { struct abs_time_t { unsigned long long mabs; } query_frame_time; struct mach_duration_t { long long value; } client_to_server_latency; } _do_not_access_value; struct _RTOptionalBase { BOOL has_value; } _do_not_access_base; } client_stats; } _storage_only_recorder_frame_timing; struct continuous_time_interval { struct continuous_time_t { unsigned long long mct; } begin; struct continuous_time_t { unsigned long long mct; } end; } _signpost_timing_present; unsigned long long _synchronization_frame_index; unsigned long long _rasterization_rate_map_count; id<MTLRasterizationRateMapSPI> _rasterization_rate_maps[2]; id<MTLRasterizationRateMapSPI> _rasterization_rate_maps_flipped[2]; MTLRasterizationRateMapDescriptor *_rasterization_rate_map_descriptors[2]; MTLRasterizationRateMapDescriptor *_rasterization_rate_map_descriptors_flipped[2]; CCRasterizationRateMapState *_cc_rasterization_rate_map_state[2]; struct WBVRRContext *_vrr_context; float _previous_max_ppd; id<MTLTexture> _cc_color_texture_as_2darray[2]; id<MTLTexture> _cc_depth_texture_as_2darray[2]; id<MTLCommandBufferSPI> _cc_command_buffer; struct cp_drawable_render_context { int _state; id<MTLCommandBuffer> _command_buffer; struct { id<MTL4CommandBuffer> buffer; unsigned long long generation; } _command_buffer4; struct cp_drawable *_drawable; CP_OBJECT_drawable_render_context_impl *_renderer; long long _resource_id; } _render_context; } _drawables[6]; } drawable_pool; CP_OBJECT_drawable_render_context_impl *render_context_renderer; struct cp_layer_events { id<MTLSharedEvent> did_app_only_render; id<MTLSharedEvent> did_all_render; } events; unsigned long long session_last_presented_frame_index; _Atomic unsigned int use_count; BOOL is_dying; } _recorder;
    struct { struct os_unfair_lock_s { unsigned int _os_unfair_lock_opaque; } lock; BOOL waiting_to_ack; CP_OBJECT_cp_swapchain *swapchain; } _recorder_staging;
    struct { struct { struct os_unfair_lock_s { unsigned int _os_unfair_lock_opaque; } lock; CP_OBJECT_cp_swapchain_link *chainlink; unsigned long long chainlink_id; BOOL should_block_rendering; } to_ack; struct { CP_OBJECT_cp_swapchain_link *chainlink; unsigned long long chainlink_id; } to_swap; } _staging;
    id<WBLayer> _remote_layer;
    CP_OBJECT_cp_layer_renderer_properties *_layer_properties;
    struct mach_duration_t { long long value; } _running_start;
    struct RTHMDClientSharedData { struct channel_seqlock_s { _Atomic unsigned long long x0; } x0; unsigned long long x1; unsigned char x2; unsigned char x3; unsigned char x4; struct WBDCalibrationData { void /* unknown type, empty encoding */ x0[2]; struct { void /* unknown type, empty encoding */ x0[4]; } x1[2]; struct { void /* unknown type, empty encoding */ x0[4]; } x2[2]; struct { void /* unknown type, empty encoding */ x0[4]; } x3[2]; struct { void /* unknown type, empty encoding */ x0[4]; } x4[2]; struct { void /* unknown type, empty encoding */ x0[4]; } x5[2]; struct { void /* unknown type, empty encoding */ x0[4]; } x6[2]; struct { void /* unknown type, empty encoding */ x0[2]; struct { void /* unknown type, empty encoding */ x0[4]; } x1[2]; int x2; BOOL x3; } x7; } x5; struct RTPose { struct { void /* unknown type, empty encoding */ x0[4]; } x0; struct { void /* unknown type, empty encoding */ x0[4]; } x1; struct { void /* unknown type, empty encoding */ x0[4]; } x2; int x3; unsigned long long x4; double x5; double x6; double x7; BOOL x8; unsigned char x9; } x6; BOOL x7; struct WBDisplayTapRenderedProperties { struct RTSize { unsigned int x0; unsigned int x1; } x0; struct RTFovInDegrees { float x0; float x1; float x2; float x3; } x1; float x2; } x8; BOOL x9; struct WBBiometricKitStimulusPoint { BOOL x0; } x10; _Atomic BOOL x11; struct WBGazeDisplayManagerSharedDefaults { struct { BOOL x0[2]; struct { BOOL x0; } x1[2]; } x0; struct { BOOL x0; BOOL x1; } x1; struct { float x0; float x1; } x2; struct WBGazeDisplayManagerStateConfigs { BOOL x0; struct { unsigned char x0; unsigned char x1; unsigned char x2; unsigned char x3; } x1; struct { struct mach_duration_t { long long x0; } x0; struct mach_duration_t { long long x0; } x1; } x2; struct WBGazeDisplayManagerShortLossGrowthLookupTable { struct WBGazeDisplayManagerLookupFrame { float x0; float x1; float x2; float x3; float x4; } x0[120]; unsigned int x1; } x3; struct WBGazeDisplayManagerRegainLookupTable { unsigned int x0[10]; unsigned int x1; } x4; struct { struct { float x0; float x1; float x2; } x0; struct { float x0; float x1; float x2; } x1; } x5; struct { float x0; float x1; } x6; float x7; } x3; BOOL x4; int x5; } x12; struct RTMCAMS8UMetadata { unsigned int x0; unsigned int x1; } x13; _Atomic BOOL x14; _Atomic BOOL x15; } *_shared_data;
    unsigned long long _layer_id;
    unsigned int _frame_repeat_count;
    unsigned long long _session_frame_index;
    unsigned long long _session_last_presented_frame_index;
    _Atomic BOOL _invalidated;
    struct { id /* block */ swapchain_link_needs_update; } _swapchain_properties;
    id<MTLDevice> _graphics_device;
    id<MTL4CommandQueue> _command_queue;
    struct { _Atomic float target_max_ppd; _Atomic float stereo_resolution_multiplexing_target_max_ppd; _Atomic BOOL temporal_anti_aliasing_enabled; struct cp_foveation_max_ppd_transition { float target_max_ppd; struct abs_time_t { unsigned long long mabs; } transition_start_time; float target_t; BOOL is_inverse_ramp; } defaults; struct cp_foveation_max_ppd_transition { float target_max_ppd; struct abs_time_t { unsigned long long mabs; } transition_start_time; float target_t; BOOL is_inverse_ramp; } stereo_resolution_multiplexing; } _foveation;
    struct { struct { BOOL enabled_set; int accumulation_curve; int coverage_type; int debug_view; int technique; double constant_accumulation_factor; double max_accumulation_factor; double accumulation_start_rate; double accumulation_plateau_rate; double accumulation_slope_modifier; void /* unknown type, empty encoding */ point_0; void /* unknown type, empty encoding */ point_1; void /* unknown type, empty encoding */ point_2; void /* unknown type, empty encoding */ point_3; void /* unknown type, empty encoding */ clipped_logistic_params; void /* unknown type, empty encoding */ configurable_logistic_params; BOOL enable_temporal_contrast_bias; double temporal_contrast_bias_multiplier; BOOL enable_variance_clipping; double std_multiplier; double inner_periphery_override; BOOL speed_of_light; double coverage; BOOL disable_occupancy; } temporal_anti_aliasing; int stereo_resolution_multiplexing_lower_ppd_eye_index; BOOL custom_foveation_params; struct WBFoveationVRRParameters { struct { float gaze_uncertainty; float min_ppd; float max_ppd; } eye[2]; float min_angular_region_1x; float min_angular_region_2x; void /* unknown type, empty encoding */ edge_tiles_ppd; BOOL use_constant_cr; } foveation_params; struct { float b; struct mach_duration_t { long long value; } duration; } foveation_max_ppd_transition; struct { unsigned char tracking_areas_debug_mode; } post_process; struct { struct nano_duration_t { long long nanos; } initial_prediction; struct nano_duration_t { long long nanos; } process_noise; struct nano_duration_t { long long nanos; } initial_estimate_deviation; } pacing_predictor; } _defaults;
    BOOL _wants_frame_rate_reduction_as_thermal_mitigation;
    struct cp_frame_statistics_t { unsigned long long frame_index; unsigned long long compositor_frame_index; unsigned long long compositor_frame_count; struct cp_time_interval_t { struct cp_time { unsigned long long cp_mach_abs_time; } start; struct cp_time { unsigned long long cp_mach_abs_time; } duration; } on_display_interval; } per_frame_statistics[10];
    id /* block */ _present_drawable_interpose;
    struct { CP_OBJECT_drawable_render_context_impl *renderer; struct cp_drawable_render_context_impl_functions { void /* function */ *create; void /* function */ *resource_update; void /* function */ *update_mask; void /* function */ *draw_stencil; void /* function */ *apply_mask; } functions; } _render_context;
    NSData *_client_owner_shared_memory;
    id /* block */ _did_update_frame_statistics_block;
    unsigned int _immersion_style;
    id /* block */ _did_update_immersion_style;
}

+ (void)initialize;

- (void)dealloc;
- (void).cxx_destruct;

@end
