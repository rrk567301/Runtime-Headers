@class MCContainer, NSMutableDictionary, MRTransitionChanges, NSMutableSet, MRTransition, MRLayer, NSMutableArray;

@interface MRLayerNavigator : MRLayer {
    MCContainer *mContainer;
    NSMutableDictionary *mSublayersForPlugs;
    MRLayer *mNextSublayer;
    MRLayer *mExtraSublayer;
    MRTransition *mCurrentTransition;
    double mTransitionStartTime;
    double mTransitionDuration;
    MRTransitionChanges *mTransitionChanges;
    double mCurrentSublayerContainerTimeOnTransitionStart;
    double mForcedTransitionProgressOffset;
    BOOL mIsInnerTransitioning;
    BOOL mTransitionIsBackwards;
    BOOL mTransitionWasAborted;
    BOOL mTransitionIsSubzero;
    BOOL mTransitionIsNextPrevious;
    BOOL mTransitionStartedWithNext;
    unsigned char mElementToDraw;
    double mCurrentSublayerInterestingTime;
    double mCurrentSublayerLazyDuration;
    double mCurrentSublayerLazyFactor;
    double mCurrentSublayerAnimationDuration;
    double mNextSublayerInterestingTime;
    double mNextSublayerLazyDuration;
    double mNextSublayerLazyFactor;
    double mNextSublayerAnimationDuration;
    double mTotalMotionDuration;
    unsigned long long mFastScrubbingStartIndex;
    double mFastScrubbingProgress;
    BOOL mIsSerializerBased;
    BOOL mIsInSlideFocusMode;
    BOOL mIsFastScrubbing;
    BOOL mPausedSublayersForTransition;
    BOOL mControlsSublayerTimes;
    BOOL mNeedsToResyncToSerializer;
    BOOL mHasWarnedDelegateAboutNearingEnd;
    MRLayer *mSublayerToPrecompute;
    id mPrecomputingTarget;
    unsigned long long mPrecomputingType;
    NSMutableArray *mHistoryBack;
    NSMutableArray *mHistoryForth;
    NSMutableSet *mPotentialTargetSublayers;
    BOOL mNeedsToUpdatePotentialTargetSublayers;
    BOOL _pauseWhenTransitionEnds;
    double _currentSublayerTheoreticalTimeIn;
    BOOL _needsToRecomputeCurrentSublayerTheoreticalTimeIn;
    double _previouslyRenderedTransitionProgress;
}

@property (readonly) NSMutableArray *sublayers;
@property (readonly) MRLayer *currentSublayer;
@property (readonly) BOOL isTransitioning;
@property BOOL historyIsEnabled;
@property (nonatomic) double forcedTransitionProgress;
@property (readonly) double currentSlideshowTime;

- (void)cleanup;
- (BOOL)isOpaque;
- (id)initWithParameters:(id)a0;
- (id)_currentState;
- (void)deactivate;
- (void)observeValueForKeyPath:(id)a0 ofObject:(id)a1 change:(id)a2 context:(void *)a3;
- (void)activate;
- (BOOL)isInfinite;
- (void)setPixelSize:(struct CGSize { double x0; double x1; })a0;
- (BOOL)hasAudio;
- (double)goBack;
- (BOOL)isAlphaFriendly;
- (id)sublayerForKey:(id)a0;
- (void)synchronizeTime;
- (void)_setNeedsToRequestRebuildAudio:(BOOL)a0;
- (double)fastScrubStart:(id)a0;
- (double)goForth;
- (void)_createExtraSublayer;
- (id)_createSublayerForPlug:(id)a0;
- (id)_createSublayerForPrecomputingWithPlug:(id)a0;
- (void)_deleteSublayer:(id)a0;
- (id)_dumpLayerWithOptions:(unsigned long long)a0;
- (void)_executeLayerCommandQueue;
- (void)_getInterestingTimesForSublayerControl;
- (BOOL)_isNative3D;
- (void)_observePlug;
- (void)_observePlugOnPreactivate;
- (void)_observeSublayer:(id)a0;
- (void)_precomputeAtTime:(double)a0 inContext:(id)a1 withArguments:(id)a2;
- (void)_preprecomputeAtTime:(double)a0 inContext:(id)a1 withArguments:(id)a2;
- (void)_prerenderSublayersAtTime:(double)a0 inContext:(id)a1 withArguments:(id)a2;
- (void)_registerTransitionForHistory:(id)a0 withDestinationPlugID:(id)a1 backwards:(BOOL)a2;
- (void)_removeExtraSublayer;
- (void)_renderAtTime:(double)a0 inContext:(id)a1 withArguments:(id)a2;
- (void)_resyncToSerializerForTime:(double)a0;
- (id)_retainedByUserRenderedImageAtTime:(double)a0 inContext:(id)a1 withArguments:(id)a2;
- (id)_transitionWithTransitionTrigger:(id)a0;
- (void)_unobservePlug;
- (void)_unobservePlugOnDepreactivate;
- (void)_unobserveSublayer:(id)a0;
- (double)abortTransition:(id)a0;
- (double)attemptToFinishTransition:(id)a0 didTransition:(BOOL *)a1 gotReversed:(BOOL *)a2;
- (void)beginMorphingToAspectRatio:(double)a0 withDuration:(double)a1;
- (BOOL)canTransitionToMoreSlides:(BOOL)a0;
- (id)currentSlideInfoForElement:(id)a0;
- (id)currentSlideInfos;
- (void)depreactivate:(BOOL)a0;
- (void)didFocusOnNextSlideWithState:(id)a0;
- (void)didFocusOnPreviousSlideWithState:(id)a0;
- (double)doActionTrigger:(id)a0;
- (double)doTransition:(id)a0 backwards:(BOOL)a1 pzr:(id)a2;
- (double)doTransition:(id)a0 backwards:(BOOL)a1 updateHistory:(BOOL)a2 deltaStartTime:(double)a3 pzr:(id)a4;
- (double)doTransition:(id)a0 withDeltaStartTime:(double)a1;
- (void)endMorphing;
- (void)endMovingCurrentSublayer;
- (void)endTransitionToSublayer;
- (BOOL)enterSlideFocusModeWithState:(id)a0;
- (void)exitSlideFocusModeWithState:(id)a0;
- (double)fastScrubCancel:(id)a0;
- (double)fastScrubEnd:(id)a0;
- (double)fastScrubUpdate:(id)a0;
- (void)fillInNextSlideInformationInState:(id)a0;
- (void)fillInPreviousSlideInformationInState:(id)a0;
- (double)finishTransition:(id)a0;
- (void)getLazyDuration:(double *)a0 lazyFactor:(double *)a1 animationDuration:(double *)a2 fromInterestingTime:(double)a3;
- (BOOL)getStartTime:(double *)a0 andDuration:(double *)a1 forMovingToElementID:(id)a2 backwards:(BOOL)a3;
- (double)gotoMoreSlidesWithAction:(id)a0 backwards:(BOOL)a1 animate:(BOOL)a2 canCatchCurrentTransition:(BOOL)a3;
- (double)gotoNextOrPreviousSlideInCurrentSublayer:(BOOL)a0;
- (double)gotoNextSublayer:(id)a0 animate:(BOOL)a1;
- (double)gotoPreviousSublayer:(id)a0 animate:(BOOL)a1;
- (BOOL)hasMoreSlidesFromTime:(double)a0 backwards:(BOOL)a1 startTime:(double *)a2 duration:(double *)a3;
- (BOOL)hasSlides;
- (BOOL)hasSomethingToRender;
- (id)initWithPlug:(id)a0 andParameters:(id)a1 inSuperlayer:(id)a2;
- (double)interestingTimeForElement:(id)a0;
- (double)interestingTimeForTime:(double)a0;
- (BOOL)isInInteractiveMode;
- (BOOL)isLoadedForTime:(double)a0;
- (void)jumpToNextMarker:(id)a0;
- (void)jumpToPreviousMarker:(id)a0;
- (void)jumpToSublayer:(id)a0 atTime:(double)a1;
- (id)patchworkAtTime:(double)a0 inContext:(id)a1 withArguments:(id)a2;
- (BOOL)prerenderForTime:(double)a0 inContext:(id)a1 withArguments:(id)a2;
- (void)resyncToSerializer;
- (void)setIsInInteractiveMode:(BOOL)a0;
- (void)setSublayer:(id)a0 forKey:(id)a1;
- (double)startMovingCurrentSublayer:(BOOL)a0;
- (id)sublayerForPlugObjectID:(id)a0 recursive:(BOOL)a1;
- (id)sublayerHitAtPoint:(struct CGPoint { double x0; double x1; })a0 onlyIfHitElement:(BOOL)a1 localPoint:(struct CGPoint { double x0; double x1; } *)a2;
- (double)transitionToNextSublayerWithDeltaStartTime:(double)a0;
- (void)updateTransition:(id)a0;
- (BOOL)willFocusOnNextSlideWithState:(id)a0 animate:(BOOL)a1;
- (BOOL)willFocusOnPreviousSlideWithState:(id)a0 animate:(BOOL)a1;

@end
