@class NSArray, NSString, NSMutableDictionary, VKLabelNavRoadGraph, NSMutableSet, NSMutableArray, VKPolylineOverlay;

@interface LabelNavRouteLabeler : NSObject {
    BOOL _isOnRoute;
    unsigned long long _stepIndex;
    BOOL _checkOnRouteLabelsAlignment;
    BOOL _disableTileParseForOneLayout;
    struct unordered_set<std::shared_ptr<md::LabelTile>, std::hash<std::shared_ptr<md::LabelTile>>, std::equal_to<std::shared_ptr<md::LabelTile>>, geo::allocator_adapter<std::shared_ptr<md::LabelTile>, mdm::zone_mallocator>> { struct __hash_table<std::shared_ptr<md::LabelTile>, std::hash<std::shared_ptr<md::LabelTile>>, std::equal_to<std::shared_ptr<md::LabelTile>>, geo::allocator_adapter<std::shared_ptr<md::LabelTile>, mdm::zone_mallocator>> { struct unique_ptr<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *[], std::__bucket_list_deallocator<geo::allocator_adapter<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::zone_mallocator>>> { void **__ptr_; struct __bucket_list_deallocator<geo::allocator_adapter<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::zone_mallocator>> { unsigned long long __size_; struct allocator_adapter<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::zone_mallocator> { struct zone_mallocator { } _allocator; } __alloc_; } __deleter_; struct __compressed_pair_padding<std::__bucket_list_deallocator<geo::allocator_adapter<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::zone_mallocator>>, false> { char __padding_[7]; } __padding2_431_; } __bucket_list_; struct __hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> { void *__next_; } __first_node_; struct allocator_adapter<std::__hash_node<std::shared_ptr<md::LabelTile>, void *>, mdm::zone_mallocator> { struct zone_mallocator { } _allocator; } __node_alloc_; unsigned long long __size_; float __max_load_factor_; } __table_; } _tiles;
    struct unordered_set<std::shared_ptr<md::LabelTile>, std::hash<std::shared_ptr<md::LabelTile>>, std::equal_to<std::shared_ptr<md::LabelTile>>, geo::allocator_adapter<std::shared_ptr<md::LabelTile>, mdm::zone_mallocator>> { struct __hash_table<std::shared_ptr<md::LabelTile>, std::hash<std::shared_ptr<md::LabelTile>>, std::equal_to<std::shared_ptr<md::LabelTile>>, geo::allocator_adapter<std::shared_ptr<md::LabelTile>, mdm::zone_mallocator>> { struct unique_ptr<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *[], std::__bucket_list_deallocator<geo::allocator_adapter<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::zone_mallocator>>> { void **__ptr_; struct __bucket_list_deallocator<geo::allocator_adapter<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::zone_mallocator>> { unsigned long long __size_; struct allocator_adapter<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::zone_mallocator> { struct zone_mallocator { } _allocator; } __alloc_; } __deleter_; struct __compressed_pair_padding<std::__bucket_list_deallocator<geo::allocator_adapter<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::zone_mallocator>>, false> { char __padding_[7]; } __padding2_431_; } __bucket_list_; struct __hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> { void *__next_; } __first_node_; struct allocator_adapter<std::__hash_node<std::shared_ptr<md::LabelTile>, void *>, mdm::zone_mallocator> { struct zone_mallocator { } _allocator; } __node_alloc_; unsigned long long __size_; float __max_load_factor_; } __table_; } _pendingTiles;
    NSMutableArray *_junctions;
    VKLabelNavRoadGraph *_roadGraph;
    NSMutableArray *_fadingLabels;
    NSMutableDictionary *_visibleLabelsByName;
    NSMutableArray *_visibleLabels;
    NSMutableSet *_visibleShieldGroups;
    unsigned long long _countVisibleOnRouteRoadSigns;
    unsigned long long _countVisibleOffRouteRoadSigns;
    unsigned long long _countVisibleRoadSigns;
    unsigned long long _maxVisibleOnRouteRoadSigns;
    unsigned long long _maxVisibleOffRouteRoadSigns;
    unsigned long long _maxVisibleRoadSigns;
    unsigned long long _maxOnRoadGraphRoadSigns;
    unsigned long long _minVisibleOffRoadGraphRoadSigns;
    unsigned long long _minVisibleProceedToRouteRoadSigns;
    BOOL _preferRightSideLabelPlacement;
    float _minSignOffsetDistance;
    NSMutableSet *_roadNamesInGuidance;
    NSMutableArray *_guidanceStepInfos;
    NSMutableArray *_routeRoadInfos;
    long long _currentRoadNameIndex;
    BOOL _checkIfRouteSubrangeChanged;
    BOOL _useRouteSubrange;
    BOOL _regenerateRoadSigns;
    BOOL _isStylesheetAnimating;
    struct PolylineCoordinate { unsigned int index; float offset; } _routeSubrangeStart;
    struct PolylineCoordinate { unsigned int index; float offset; } _routeSubrangeEnd;
    struct shared_ptr<md::NavCurrentRoadSign> { struct NavCurrentRoadSign *__ptr_; struct __shared_weak_count *__cntrl_; } _currentRoadSign;
    BOOL _isCurrentRoadSignVisible;
    unsigned long long _debugCachedMaxVisibleOffRouteRoadSigns;
    unsigned long long _debugCachedMaxVisibleOnRouteRoadSigns;
    struct shared_ptr<gss::StylesheetManager<gss::PropertyID>> { void *__ptr_; struct __shared_weak_count *__cntrl_; } _styleManager;
    BOOL _shouldLabelOppositeCarriageways;
    struct vector<md::AvoidanceRectWithPriority, geo::allocator_adapter<md::AvoidanceRectWithPriority, mdm::zone_mallocator>> { struct AvoidanceRectWithPriority *__begin_; struct AvoidanceRectWithPriority *__end_; struct AvoidanceRectWithPriority *__cap_; struct allocator_adapter<md::AvoidanceRectWithPriority, mdm::zone_mallocator> { struct zone_mallocator { } _allocator; } __alloc_; } _avoidanceRects;
    BOOL _hasPendingTilesInSnappingRegion;
    BOOL _needsDebugConsoleClear;
    struct range_map<geo::Unit<geo::RadianUnitDescription, float>, md::OrientationAction, std::less<geo::Unit<geo::RadianUnitDescription, float>>, std::allocator<std::pair<const gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>>> { struct map<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction, geo::range_map<geo::Unit<geo::RadianUnitDescription, float>, md::OrientationAction>::RangeCompare, std::allocator<std::pair<const gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>>> { struct __tree<std::__value_type<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>, std::__map_value_compare<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, std::__value_type<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>, geo::range_map<geo::Unit<geo::RadianUnitDescription, float>, md::OrientationAction>::RangeCompare>, std::allocator<std::__value_type<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>>> { void *__begin_node_; struct __tree_end_node<std::__tree_node_base<void *> *> { void *__left_; } __end_node_; unsigned long long __size_; } __tree_; } _storage; } _leftTurnOrientations;
    struct range_map<geo::Unit<geo::RadianUnitDescription, float>, md::OrientationAction, std::less<geo::Unit<geo::RadianUnitDescription, float>>, std::allocator<std::pair<const gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>>> { struct map<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction, geo::range_map<geo::Unit<geo::RadianUnitDescription, float>, md::OrientationAction>::RangeCompare, std::allocator<std::pair<const gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>>> { struct __tree<std::__value_type<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>, std::__map_value_compare<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, std::__value_type<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>, geo::range_map<geo::Unit<geo::RadianUnitDescription, float>, md::OrientationAction>::RangeCompare>, std::allocator<std::__value_type<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>>> { void *__begin_node_; struct __tree_end_node<std::__tree_node_base<void *> *> { void *__left_; } __end_node_; unsigned long long __size_; } __tree_; } _storage; } _rightTurnOrientations;
    BOOL _isSnappingReady;
    struct MultiRectRegion { struct set<gm::Box<double, 2>, md::MultiRectSetCompare, std::allocator<gm::Box<double, 2>>> { struct __tree<gm::Box<double, 2>, md::MultiRectSetCompare, std::allocator<gm::Box<double, 2>>> { void *__begin_node_; struct __tree_end_node<std::__tree_node_base<void *> *> { void *__left_; } __end_node_; unsigned long long __size_; } __tree_; } _rects; struct Box<double, 2> { struct Matrix<double, 2, 1> { double _e[2]; } _minimum; struct Matrix<double, 2, 1> { double _e[2]; } _maximum; } _enclosingRect; } _snappingRegion;
    NSArray *_matchedPaths;
    BOOL _inOverviewMode;
}

@property (nonatomic) BOOL drawRoadSigns;
@property (retain, nonatomic) VKPolylineOverlay *route;
@property (retain, nonatomic) NSString *currentLocationText;
@property (retain, nonatomic) NSString *currentRoadName;
@property (retain, nonatomic) NSString *currentShieldGroup;
@property (nonatomic) struct PolylineCoordinate { unsigned int index; float offset; } routeUserOffset;
@property (readonly, nonatomic) struct vector<std::shared_ptr<md::NavLabel>, geo::allocator_adapter<std::shared_ptr<md::NavLabel>, mdm::zone_mallocator>> { void *__begin_; void *__end_; void *__cap_; struct allocator_adapter<std::shared_ptr<md::NavLabel>, mdm::zone_mallocator> { struct zone_mallocator { } _allocator; } __alloc_; } activeSigns;
@property (readonly, nonatomic) struct vector<std::shared_ptr<md::NavLabel>, geo::allocator_adapter<std::shared_ptr<md::NavLabel>, mdm::zone_mallocator>> { void *__begin_; void *__end_; void *__cap_; struct allocator_adapter<std::shared_ptr<md::NavLabel>, mdm::zone_mallocator> { struct zone_mallocator { } _allocator; } __alloc_; } visibleSigns;
@property (readonly, nonatomic) BOOL needsLayout;
@property (readonly, nonatomic) BOOL areAllTilesReady;
@property (readonly, nonatomic) float currentRoadSignPixelHeight;
@property (nonatomic) BOOL debugDisableRoadSignLimit;
@property (nonatomic) BOOL debugEnableShieldsOnRouteLine;
@property (nonatomic) void *artworkCache;

- (void)_updateCurrentRoadInfo;
- (void)_tryAddLabel:(id)a0 navContext:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a1 labelCollisionEnabled:(BOOL)a2;
- (BOOL)_updateActiveRouteRange;
- (void)_tryAddRoadSignForRoad:(id)a0 isShield:(BOOL)a1 navContext:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a2 labelCollisionEnabled:(BOOL)a3;
- (void)setStyleManager:(struct shared_ptr<gss::StylesheetManager<gss::PropertyID>> { void *x0; struct __shared_weak_count *x1; })a0;
- (void)_initalizeCurrentRoadInfo;
- (void)drawNavOverlayDebugView:(void *)a0 navContext:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a1;
- (void)_generateCurrentRoadSignWithContext:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a0;
- (BOOL)needsDebugDraw;
- (void)_createOrUpdateLabelForRoad:(id)a0 isShield:(BOOL)a1 navContext:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a2 hopOffsetDistance:(float)a3;
- (struct RoadSignOrientationResolver { void *x0; struct Unit<geo::RadianUnitDescription, float> { float x0; } x1; unsigned char x2; })createRoadSignOrientationResolver:(id)a0 navContext:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a1;
- (BOOL)_collideLabel:(id)a0 activeLabel:(id)a1 labelsToRemove:(id)a2;
- (void)clearSceneIsMemoryWarning:(BOOL)a0;
- (unsigned char)resolveOrientation:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a0 road:(id)a1 currentOrientation:(unsigned char)a2;
- (id)init;
- (void)_addLabelsForJunctions:(id)a0 withContext:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a1 maxLabelsToAdd:(unsigned long long)a2 useAllJunctions:(BOOL)a3 placeShieldsFrontToBack:(BOOL)a4;
- (void)_updatePreferredLabelPlacements;
- (void)_dedupOffRouteRoads;
- (void)_addLabelsAtJunctions:(id)a0 withContext:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a1 maxLabelsToAdd:(unsigned long long)a2;
- (BOOL)_addJunctionsForTile:(const void *)a0;
- (void)styleManagerDidFinishAnimating;
- (void)_updateRoadStarts;
- (void)styleManagerDidChange:(BOOL)a0;
- (void)debugDraw:(id)a0 overlayConsole:(void *)a1 navContext:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a2;
- (void)_updateRoadsInGuidance;
- (void)grabTilesFromScene:(const void *)a0;
- (void)setMaxVisibleRoadsigns:(unsigned int)a0;
- (void)_updateUniqueOffRouteRoads;
- (void)styleManagerDidStartAnimating;
- (id).cxx_construct;
- (void)_tryAddRoadSignForJunction:(id)a0 navContext:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a1 labelCollisionEnabled:(BOOL)a2;
- (void)layoutForDisplayWithNavContext:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a0 labels:(void *)a1;
- (unsigned char)orientationForRoadSign:(id)a0 roadLabel:(id)a1 navContext:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a2;
- (void)drawRoadSignOrientationDebugView:(void *)a0 navContext:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a1;
- (void)synchStagingWithDisplay;
- (void)prepareForLayoutForStaging;
- (unsigned char)computeRoutePositionForPOIAtPixel:(const void *)a0 currentPosition:(unsigned char)a1 context:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a2;
- (void)layoutForStagingWithNavContext:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a0 avoidanceRects:(const void *)a1 options:(const struct LabelUpdateOptions { BOOL x0; BOOL x1; BOOL x2; BOOL x3; BOOL x4; BOOL x5; unsigned int x6; } *)a2;
- (void)_reloadRouteJunctions;
- (BOOL)_findRouteOverlappingJunctionFrom:(long long)a0 routeJunctions:(void *)a1 lookBackward:(BOOL)a2 firstOverlap:(long long *)a3 secondOverlap:(long long *)a4;
- (void).cxx_destruct;
- (void)_refreshGuidanceRoadNames;
- (void)_addVisibleSigns;

@end
