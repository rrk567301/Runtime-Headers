@class NSArray, NSString, NSLocale, NSIndexPath;

@interface CHTokenizedTextResult : CHTokenizedResult <NSCopying, NSMutableCopying, NSSecureCoding> {
    NSArray *_tokenColumns;
    long long _recognizerGenerationIdentifier;
    long long _precedingLineBreaks;
    long long _changeableCount;
    NSArray *_inputStrokeIdentifiers;
    NSLocale *_locale;
    int _baseWritingDirection;
}

@property (class, readonly) BOOL supportsSecureCoding;

@property (copy, nonatomic) NSArray *originalTokens;
@property (readonly, nonatomic) long long tokenColumnCount;
@property (readonly, nonatomic) long long changeableTokenColumnCount;
@property (readonly, nonatomic) BOOL isSingleTokenResult;
@property (readonly, copy, nonatomic) NSString *trailingSeparator;
@property (readonly, nonatomic) int baseWritingDirection;
@property (readonly, copy, nonatomic) NSArray *transcriptionPaths;
@property (readonly, copy, nonatomic) NSArray *transcriptionPathScores;
@property (readonly, copy, nonatomic) NSString *topTranscription;
@property (readonly, copy, nonatomic) NSString *rawTranscription;
@property (readonly, copy, nonatomic) NSIndexPath *rawTranscriptionPath;
@property (readonly, copy, nonatomic) NSString *refinableTranscription;
@property (readonly, copy, nonatomic) NSIndexPath *refinableTranscriptionPath;
@property (readonly, copy, nonatomic) NSString *topModelTranscription;
@property (readonly, copy, nonatomic) NSIndexPath *topModelTranscriptionPath;
@property (readonly, nonatomic) NSString *recognizerDebugDescription;

+ (id)loadFromFile:(id)a0;
+ (id)compressResult:(id)a0 atColumnIndexes:(id)a1;
+ (id)resultRestoringRawPathInResult:(id)a0;
+ (BOOL)areTokenRowsEquivalent:(id)a0 otherRow:(id)a1;
+ (id)extendedToken:(id)a0 withStrokeIndexSet:(id)a1 alignmentScore:(double)a2 bounds:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a3;
+ (BOOL)isTextTranscriptionUnitConversion:(id)a0 locales:(id)a1;
+ (BOOL)isTextTranscriptionVariableAssignment:(id)a0 outVariable:(id *)a1;
+ (long long)mergeTokenRow:(id)a0 intoUniqueRows:(id)a1;
+ (struct CGPath { } *)newBaselinePathForTokens:(id)a0 strokeIdentifiers:(id)a1 strokeProvider:(id)a2;
+ (id)resultsBySwapping:(id)a0 swappableColumns:(id)a1 locales:(id)a2 topLocaleIndex:(long long)a3 topLocale:(id)a4;
+ (id)swappableColumnIndexesInResults:(id)a0 locales:(id)a1 topLocaleIndex:(long long)a2 swappableIndex:(long long)a3 shouldReverseSwappableColumns:(BOOL)a4;
+ (id)tokenizedTextResultFromResults:(id)a0 shouldPerformStrictFiltering:(BOOL)a1 doesTopLocaleRequireSpecialHandling:(BOOL)a2 hasSwap:(BOOL)a3;
+ (id)tokenizedTextResultWithString:(id)a0 strokeIndexes:(id)a1 bounds:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a2 trailingSeparator:(id)a3 recognizerGenerationIdentifier:(long long)a4 defaultTokenScores:(double)a5;
+ (id)tokenizedTextResultWithString:(id)a0 strokeIndexes:(id)a1 bounds:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a2 trailingSeparator:(id)a3 recognizerGenerationIdentifier:(long long)a4 defaultTokenScores:(double)a5 originalBounds:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a6 principalLines:(struct { struct { struct CGPoint { double x0; double x1; } x0; struct CGPoint { double x0; double x1; } x1; } x0; struct { struct CGPoint { double x0; double x1; } x0; struct CGPoint { double x0; double x1; } x1; } x1; struct { struct CGPoint { double x0; double x1; } x0; struct CGPoint { double x0; double x1; } x1; } x2; struct { struct CGPoint { double x0; double x1; } x0; struct CGPoint { double x0; double x1; } x1; } x3; })a7 principalPoints:(id)a8;
+ (id)tokenizedTextResultWithToken:(id)a0 trailingSeparator:(id)a1 recognizerGenerationIdentifier:(long long)a2;

- (id)mutableCopyWithZone:(struct _NSZone { } *)a0;
- (BOOL)isValid;
- (id)locale;
- (void)encodeWithCoder:(id)a0;
- (double)score;
- (id)init;
- (void)setLocale:(id)a0;
- (id)description;
- (id)initWithCoder:(id)a0;
- (unsigned long long)hash;
- (BOOL)isEqual:(id)a0;
- (void).cxx_destruct;
- (id)strokeIndexesForColumnsInRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })a0;
- (BOOL)hasValidColumns;
- (id)initWithBestPathTokens:(id)a0 pathProbabilities:(id)a1 trailingSeparator:(id)a2 recognizerGenerationIdentifier:(long long)a3 changeableColumnCount:(long long)a4 originalTokens:(id)a5;
- (BOOL)isPathOriginal:(id)a0;
- (double)averageTokenRecognitionScoreForColumnRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })a0;
- (id)changeableColumnCountUpdatedResultWithHistory:(id)a0 phraseLexicon:(struct _LXLexicon { } *)a1 maxPhraseLength:(long long)a2;
- (id)commonTopStrokeSetsWithResult:(id)a0 shouldReverseOtherColumns:(BOOL)a1;
- (id)descriptionWithSensitiveInformation:(BOOL)a0;
- (BOOL)doGivenPaths:(id)a0 coverAllTokensInPath:(id)a1;
- (void)enumerateOriginalTokensWithBlock:(id /* block */)a0;
- (void)enumerateTokensInTopTranscriptionPathWithBlock:(id /* block */)a0;
- (void)enumerateTokensInTranscriptionPath:(id)a0 columnRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })a1 tokenProcessingBlock:(id /* block */)a2;
- (BOOL)hasTextReplacementsInColumnRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })a0;
- (BOOL)hasTokenAtLocation:(struct { long long x0; long long x1; long long x2; })a0;
- (BOOL)hasValidPaths;
- (BOOL)hasValidPrincipalLinesForPath:(id)a0;
- (double)heuristicTextScoreForColumnRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })a0;
- (long long)inLexiconTokenCountInTranscriptionPath:(id)a0;
- (id)initWithBestPathTokens:(id)a0 pathProbabilities:(id)a1 trailingSeparator:(id)a2 recognizerGenerationIdentifier:(long long)a3 originalTokens:(id)a4;
- (id)initWithTokenColumns:(id)a0 transcriptionPaths:(id)a1 scores:(id)a2 recognizerGenerationIdentifier:(long long)a3 isMinimalDrawingResult:(BOOL)a4 baseWritingDirection:(int)a5 originalTokens:(id)a6;
- (id)initWithTokenColumns:(id)a0 transcriptionPaths:(id)a1 scores:(id)a2 recognizerGenerationIdentifier:(long long)a3 originalTokens:(id)a4;
- (id)initWithTokenColumns:(id)a0 transcriptionPaths:(id)a1 scores:(id)a2 trailingSeparator:(id)a3 recognizerGenerationIdentifier:(long long)a4 changeableColumnCount:(long long)a5 isMinimalDrawingResult:(BOOL)a6 baseWritingDirection:(int)a7;
- (id)initWithTokenColumns:(id)a0 transcriptionPaths:(id)a1 scores:(id)a2 trailingSeparator:(id)a3 recognizerGenerationIdentifier:(long long)a4 changeableColumnCount:(long long)a5 isMinimalDrawingResult:(BOOL)a6 baseWritingDirection:(int)a7 originalTokens:(id)a8;
- (id)initWithTokenColumns:(id)a0 transcriptionPaths:(id)a1 scores:(id)a2 trailingSeparator:(id)a3 recognizerGenerationIdentifier:(long long)a4 changeableColumnCount:(long long)a5 originalTokens:(id)a6;
- (id)initWithTokenColumns:(id)a0 transcriptionPaths:(id)a1 scores:(id)a2 trailingSeparator:(id)a3 recognizerGenerationIdentifier:(long long)a4 originalTokens:(id)a5;
- (id)inputStrokeIdentifiers;
- (BOOL)isEqualToTokenizedTextResult:(id)a0;
- (BOOL)isNonTextCandidateTranscriptionWithStrictFiltering:(BOOL)a0;
- (struct { double x0; double x1; })languageFitnessForLocale:(id)a0 recognitionMode:(int)a1;
- (id)lastTokenStrokeIndexes;
- (id)modifiedResultWithBestPathTokens:(id)a0 pathProbabilities:(id)a1;
- (id)originalTranscription;
- (id)phraseCaseCorrectedResultWithHistory:(id)a0 phraseLexicon:(struct _LXLexicon { } *)a1 maxPhraseLength:(long long)a2;
- (long long)precedingLineBreaks;
- (id)precedingSeparatorForRawTranscriptionPath;
- (id)precedingSeparatorForToken:(id)a0;
- (id)precedingSeparatorForTopModelTranscriptionPath;
- (id)precedingSeparatorForTopTranscriptionPath;
- (long long)recognizerGenerationIdentifier;
- (void)setInputStrokeIdentifiers:(id)a0;
- (BOOL)shouldFilterOutStringForToken:(id)a0 isGibberish:(BOOL *)a1 shouldPerformStrictFiltering:(BOOL)a2;
- (BOOL)shouldFilterSingleCharacterResult;
- (BOOL)shouldFilterSingleTokenResult;
- (id)strokeIndexSetsInPath:(id)a0 columnRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })a1;
- (id)strokeIndexes;
- (id)subResultWithColumnRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })a0;
- (id)textRecognitionResultArray;
- (id)textRecognitionResultArrayGivenHistory:(id)a0;
- (id)tokenAtLocation:(struct { long long x0; long long x1; long long x2; })a0;
- (id)tokenColumns;
- (long long)tokenCountInTranscriptionPath:(id)a0;
- (id)tokenRowsAtColumnIndex:(long long)a0;
- (id)tokenizedResultWithFilteredPaths:(double)a0;
- (id)tokenizedTextResultByAppendingTokenizedTextResult:(id)a0 shouldForceSpace:(BOOL)a1;
- (id)tokensAlignedWithStrokes:(id)a0 transcriptionPath:(id)a1 strokeProvider:(id)a2;
- (id)tokensFromTranscriptionPath:(id)a0;
- (id)tokensFromTranscriptionPath:(id)a0 characterRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })a1;
- (id)tokensInTranscriptionPath:(id)a0 atColumnIndex:(long long)a1;
- (BOOL)transcriptionPathsHaveSameSegmentation:(id)a0 otherPath:(id)a1;
- (id)transcriptionWithPath:(id)a0 columnRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })a1 filterLowConfidence:(BOOL)a2;
- (id)transcriptionWithPath:(id)a0 columnRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })a1 filterLowConfidence:(BOOL)a2 allowPrecedingSeparator:(BOOL)a3;
- (id)transcriptionWithPath:(id)a0 columnRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })a1 filterLowConfidence:(BOOL)a2 excludeGibberish:(BOOL)a3 allowPrecedingSeparator:(BOOL)a4 rejectionRate:(double *)a5 tokenProcessingBlock:(id /* block */)a6;
- (id)transcriptionWithPath:(id)a0 columnRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })a1 filterLowConfidence:(BOOL)a2 excludeGibberish:(BOOL)a3 rejectionRate:(double *)a4 tokenProcessingBlock:(id /* block */)a5;

@end
