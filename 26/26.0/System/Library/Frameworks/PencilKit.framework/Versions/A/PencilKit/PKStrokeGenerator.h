@class PKStroke, NSArray, NSObject;
@protocol OS_dispatch_queue, PKStrokeGeneratorDelegate, OS_dispatch_semaphore;

@interface PKStrokeGenerator : NSObject <PKInputProvider> {
    double _latestNonPredictedTimestamp;
    struct vector<PKInputPoint, std::allocator<PKInputPoint>> { struct *__begin_; struct *__end_; struct *__cap_; } _drawPoints;
    struct vector<_PKStrokePoint, std::allocator<_PKStrokePoint>> { struct _PKStrokePoint *__begin_; struct _PKStrokePoint *__end_; struct _PKStrokePoint *__cap_; } _outputPoints;
    long long _outputImmutableCount;
    BOOL _inputHasChanged;
    struct _PKStrokePoint { double timestamp; struct CGPoint { double x; double y; } location; double radius; double aspectRatio; double edgeWidth; double force; double azimuth; double altitude; double opacity; double radius2; double threshold; } _baseValues;
    NSObject<OS_dispatch_queue> *_inputQueue;
    PKStroke *_currentStroke;
    long long _currentInputType;
    unsigned long long _currentActiveInputProperties;
    long long _immutableCount;
    long long _missedUpdates;
    struct vector<PKInputPoint, std::allocator<PKInputPoint>> { struct *__begin_; struct *__end_; struct *__cap_; } _updatedDrawPoints;
    BOOL _drawingEndedButNotFinished;
    double _endTimestamp;
    NSObject<OS_dispatch_semaphore> *_drawingWaitForFinishSemaphore;
    BOOL _keepPredictedTouchesAtEndOfStroke;
    BOOL _currentShouldClearAzimuth;
    BOOL _currentRollAngleEnabled;
    double _currentBaseRollAngle;
    double _currentAdditionalRollAngle;
    BOOL _alwaysUseRollAngleForFountainPen;
    struct os_unfair_lock_s { unsigned int _os_unfair_lock_opaque; } _baseRollAngleLock;
    double _currentStrokeRollBaseValue;
    double _currentStrokeRollDeltaMin;
    double _currentStrokeRollDeltaMax;
    NSArray *_allInputPointFilters;
    BOOL _shouldSetIsSafeForStyleInventorFlag;
}

@property (nonatomic) struct CGAffineTransform { double a; double b; double c; double d; double tx; double ty; } rulerTransform;
@property (nonatomic) BOOL useRuler;
@property (nonatomic) double rulerWidth;
@property (nonatomic) BOOL isSnappedToRulerTopSide;
@property (nonatomic) BOOL canSnapToRuler;
@property (nonatomic) double strokeMaxForce;
@property struct CGPoint { double x; double y; } lastPoint;
@property (retain, nonatomic) NSObject<OS_dispatch_queue> *outputQueue;
@property (nonatomic) void *inputProvider;
@property (nonatomic) void *pixelSmoothingFilter;
@property (nonatomic) void *pointReductionFilter;
@property (nonatomic) void *startHookFilter;
@property (nonatomic) void *endHookFilter;
@property (nonatomic) void *velocityFilter;
@property (nonatomic) void *directionAngleFilter;
@property (nonatomic) void *inputSmoother;
@property (nonatomic) void *noiseSmoother;
@property (nonatomic) void *propertySmoother;
@property (nonatomic) void *inputToOutputFilter;
@property (nonatomic) void *startCapFilter;
@property (nonatomic) void *animationFilter;
@property (nonatomic) void *azimuthFilter;
@property (nonatomic) void *endDelayFilter;
@property (nonatomic) void *endCapFilter;
@property (nonatomic) void *fountainPenFilter;
@property (nonatomic) void *rulerExtremaFilter;
@property (nonatomic) void *estimatedAltitudeAndAzimuthFilter;
@property (nonatomic) void *compressionFilter;
@property (nonatomic) void *decompressionFilter;
@property BOOL isSnappedToRuler;
@property (readonly) BOOL lastPointIsMasked;
@property double eraserIndicatorAlpha;
@property (nonatomic) double inputScale;
@property (readonly) double currentStrokeRollDelta;
@property (nonatomic) double baseRollAngle;
@property (weak, nonatomic) id<PKStrokeGeneratorDelegate> delegate;
@property (readonly, nonatomic) long long inputType;
@property (readonly, nonatomic) unsigned long long activeInputProperties;
@property (nonatomic) BOOL captureLiveData;
@property (nonatomic) BOOL isPreviewing;
@property double additionalRollAngle;
@property BOOL rollAngleEnabled;
@property BOOL shouldClearAzimuth;

+ (void)initialize;
+ (struct vector<PKInputPoint, std::allocator<PKInputPoint>> { struct *x0; struct *x1; struct *x2; })inputPointsFromPath:(struct CGPath { } *)a0 maxSegmentLength:(double)a1 velocityForDistanceFunction:(id /* block */)a2;
+ (struct vector<PKInputPoint, std::allocator<PKInputPoint>> { struct *x0; struct *x1; struct *x2; })inputPointsFromPoints:(const void *)a0 velocityForDistanceFunction:(id /* block */)a1;

- (void)reset;
- (void)dealloc;
- (void)addPoint:(struct { union { struct CGPoint { double x0; double x1; } x0; struct CGPoint { double x0; double x1; } x1; } x0; double x1; double x2; double x3; double x4; double x5; double x6; double x7; BOOL x8; long long x9; double x10; double x11; BOOL x12; double x13; long long x14; long long x15; })a0;
- (id)init;
- (void)addPoints:(struct vector<PKInputPoint, std::allocator<PKInputPoint>> { struct *x0; struct *x1; struct *x2; })a0;
- (id).cxx_construct;
- (void).cxx_destruct;
- (long long)inputType;
- (void)drawingCancelledWithCompletion:(id /* block */)a0;
- (double)latestTimestamp;
- (void)_drawingAddPoint:(struct { union { struct CGPoint { double x0; double x1; } x0; struct CGPoint { double x0; double x1; } x1; } x0; double x1; double x2; double x3; double x4; double x5; double x6; double x7; BOOL x8; long long x9; double x10; double x11; BOOL x12; double x13; long long x14; long long x15; })a0;
- (void)_drawingUpdateAllPointsDidTimeout:(BOOL)a0 updateSemaphore:(BOOL)a1;
- (void)_drawingUpdateAllPointsDidTimeoutWithStrokeUUID:(id)a0;
- (struct _PKStrokePoint { double x0; struct CGPoint { double x0; double x1; } x1; double x2; double x3; double x4; double x5; double x6; double x7; double x8; double x9; double x10; })_latestStrokePoint;
- (id)_newStrokeWithCurrentDataAndStrokeDataUUID:(id)a0;
- (void)_removePredictedTouches;
- (void)_updatePredictedTouches;
- (void)allowSnappingToRuler:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a0 width:(double)a1;
- (void)closeStroke;
- (void)configureFilters;
- (unsigned long long)copyInputUpdatedRangeFromIndex:(unsigned long long)a0 into:(void *)a1;
- (double)distanceToRulerCenter:(struct CGPoint { double x0; double x1; })a0;
- (void)drawingBeganWithStroke:(id)a0 inputType:(long long)a1 activeInputProperties:(unsigned long long)a2 inputScale:(double)a3 start:(id /* block */)a4;
- (void)drawingEndedEstimatesTimeout:(double)a0 completion:(id /* block */)a1;
- (void)drawingUpdateAllPoints;
- (void)drawingUpdateAllPointsDidTimeoutWithStrokeUUID:(id)a0;
- (void)drawingUpdatePoint:(struct { union { struct CGPoint { double x0; double x1; } x0; struct CGPoint { double x0; double x1; } x1; } x0; double x1; double x2; double x3; double x4; double x5; double x6; double x7; BOOL x8; long long x9; double x10; double x11; BOOL x12; double x13; long long x14; long long x15; })a0;
- (long long)fetchFilteredPointsFromIndex:(long long)a0 accessBlock:(id /* block */)a1;
- (void *)getInputUpdatedRangeFromIndex:(inout unsigned long long *)a0;
- (struct CGPoint { double x0; double x1; })getRulerSnapLineOriginAndTangent:(struct CGPoint { double x0; double x1; } *)a0 andNormal:(struct CGPoint { double x0; double x1; } *)a1;
- (void *)getUpdatedRangeFromIndex:(inout unsigned long long *)a0;
- (id)initWithStrokeNoiseSmoothing:(BOOL)a0;
- (double)latestNonPredictedTimestamp;
- (void)maskToRuler;
- (id)newStrokeWithCurrentData;
- (id)newStrokeWithCurrentDataCopy;
- (struct _PKStrokePoint { double x0; struct CGPoint { double x0; double x1; } x1; double x2; double x3; double x4; double x5; double x6; double x7; double x8; double x9; double x10; })outputCurrentStrokePoint:(struct { union { struct CGPoint { double x0; double x1; } x0; struct CGPoint { double x0; double x1; } x1; } x0; double x1; double x2; double x3; double x4; double x5; double x6; double x7; BOOL x8; long long x9; double x10; double x11; BOOL x12; double x13; long long x14; long long x15; })a0 lastPoint:(struct { union { struct CGPoint { double x0; double x1; } x0; struct CGPoint { double x0; double x1; } x1; } x0; double x1; double x2; double x3; double x4; double x5; double x6; double x7; BOOL x8; long long x9; double x10; double x11; BOOL x12; double x13; long long x14; long long x15; })a1;
- (void *)outputFilter;
- (struct _PKStrokePoint { double x0; struct CGPoint { double x0; double x1; } x1; double x2; double x3; double x4; double x5; double x6; double x7; double x8; double x9; double x10; })outputPoint:(struct { union { struct CGPoint { double x0; double x1; } x0; struct CGPoint { double x0; double x1; } x1; } x0; double x1; double x2; double x3; double x4; double x5; double x6; double x7; BOOL x8; long long x9; double x10; double x11; BOOL x12; double x13; long long x14; long long x15; })a0 baseValues:(struct _PKStrokePoint { double x0; struct CGPoint { double x0; double x1; } x1; double x2; double x3; double x4; double x5; double x6; double x7; double x8; double x9; double x10; })a1 lastPoint:(struct { union { struct CGPoint { double x0; double x1; } x0; struct CGPoint { double x0; double x1; } x1; } x0; double x1; double x2; double x3; double x4; double x5; double x6; double x7; BOOL x8; long long x9; double x10; double x11; BOOL x12; double x13; long long x14; long long x15; })a2;
- (void)resetFilters;
- (void)setupForInk:(id)a0 maximumSupportedContentVersion:(long long)a1;
- (BOOL)shouldSnapPointToRuler:(struct CGPoint { double x0; double x1; })a0;
- (struct CGPoint { double x0; double x1; })snapPointToRuler:(struct CGPoint { double x0; double x1; })a0;
- (void)snapToRuler;
- (id)strokeFromInputPoints:(void *)a0 inputType:(long long)a1 ink:(id)a2 inputScale:(double)a3 randomSeed:(unsigned int)a4 strokeClass:(Class)a5;
- (id)strokeFromLineSegments:(const void *)a0 maxSegmentLength:(double)a1 ink:(id)a2 inputScale:(double)a3 strokeClass:(Class)a4;
- (id)strokeFromPath:(struct CGPath { } *)a0 ink:(id)a1 inputScale:(double)a2 maxSegmentLength:(double)a3 velocityForDistanceFunction:(id /* block */)a4 strokeClass:(Class)a5;
- (id)strokeFromPoints:(struct CGPoint { double x0; double x1; } *)a0 count:(unsigned long long)a1 ink:(id)a2 inputScale:(double)a3 strokeClass:(Class)a4;
- (id)strokeFromPoints:(const void *)a0 sourceStroke:(id)a1 inputScale:(double)a2 averageInputPoint:(struct { union { struct CGPoint { double x0; double x1; } x0; struct CGPoint { double x0; double x1; } x1; } x0; double x1; double x2; double x3; double x4; double x5; double x6; double x7; BOOL x8; long long x9; double x10; double x11; BOOL x12; double x13; long long x14; long long x15; })a3;
- (void)updateImmutableCount;
- (void)updateRulerSnapping;
- (void)whenFinishedProcessingPointsCallCompletion:(id /* block */)a0;

@end
